package com.calai.backend.foodlog.controller;

import com.calai.backend.auth.security.AuthContext;
import com.calai.backend.common.web.RequestIdFilter;
import com.calai.backend.foodlog.dto.FoodLogEnvelope;
import com.calai.backend.foodlog.dto.FoodLogListResponse;
import com.calai.backend.foodlog.dto.FoodLogOverrideRequest;
import com.calai.backend.foodlog.service.*;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.time.LocalDate;

@RequiredArgsConstructor
@RestController
@RequestMapping("/api/v1/food-logs")
public class FoodLogController {

    private final AuthContext auth;
    private final FoodLogService service;
    private final FoodLogDeleteService deleteService;
    private final FoodLogHistoryService historyService;
    private final FoodLogOverrideService overrideService;

    @PostMapping(value = "/album", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public FoodLogEnvelope album(
            @RequestHeader(value = "X-Client-Timezone", required = false) String clientTz,
            @RequestPart("file") MultipartFile file,
            HttpServletRequest req
    ) throws Exception {
        Long uid = auth.requireUserId();
        String requestId = RequestIdFilter.getOrCreate(req);
        return service.createAlbum(uid, clientTz, file, requestId);
    }

    /**
     * ✅ S4-08：相機拍照入口（multipart）
     * deviceCapturedAtUtc：App 端可用 Instant.now().toString() 傳上來（可選）
     */
    @PostMapping(value = "/photo", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public FoodLogEnvelope photo(
            @RequestHeader(value = "X-Client-Timezone", required = false) String clientTz,
            @RequestPart("file") MultipartFile file,
            @RequestPart(value = "deviceCapturedAtUtc", required = false) String deviceCapturedAtUtc,
            HttpServletRequest req
    ) throws Exception {
        Long uid = auth.requireUserId();
        String requestId = RequestIdFilter.getOrCreate(req);
        return service.createPhoto(uid, clientTz, deviceCapturedAtUtc, file, requestId);
    }

    @GetMapping("/{id}")
    public FoodLogEnvelope getOne(@PathVariable String id, HttpServletRequest req) {
        Long uid = auth.requireUserId();
        String requestId = RequestIdFilter.getOrCreate(req);
        return service.getOne(uid, id, requestId);
    }

    @PostMapping("/{id}/retry")
    public FoodLogEnvelope retry(@PathVariable String id, HttpServletRequest req) {
        Long uid = auth.requireUserId();
        String requestId = RequestIdFilter.getOrCreate(req);
        return service.retry(uid, id, requestId);
    }

    @DeleteMapping("/{id}")
    public FoodLogEnvelope deleteOne(@PathVariable String id, HttpServletRequest req) {
        Long uid = auth.requireUserId();
        String requestId = RequestIdFilter.getOrCreate(req);
        return deleteService.deleteOne(uid, id, requestId);
    }

    @PostMapping("/{id}/save")
    public FoodLogEnvelope save(@PathVariable String id, HttpServletRequest req) {
        Long uid = auth.requireUserId();
        String requestId = RequestIdFilter.getOrCreate(req);
        return historyService.save(uid, id, requestId);
    }

    /**
     * ✅ 保留你原本的 SAVED 列表（不破壞既有 App）
     */
    @GetMapping
    public FoodLogListResponse listSaved(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate fromLocalDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate toLocalDate,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            HttpServletRequest req
    ) {
        Long uid = auth.requireUserId();
        String requestId = RequestIdFilter.getOrCreate(req);
        return historyService.listSaved(uid, fromLocalDate, toLocalDate, page, size, requestId);
    }

    /**
     * ✅ S4-10：通用 history（給 UI 切換 Draft/Saved/Failed/Pending）
     * 避免跟 @GetMapping("/") 衝突，所以用 /history
     */
    @GetMapping("/history")
    public FoodLogListResponse history(
            @RequestParam String status, // DRAFT/SAVED/FAILED/PENDING
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate fromLocalDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate toLocalDate,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            HttpServletRequest req
    ) {
        Long uid = auth.requireUserId();
        String requestId = RequestIdFilter.getOrCreate(req);
        return historyService.listByStatus(uid, status, fromLocalDate, toLocalDate, page, size, requestId);
    }

    @PostMapping(value = "/{id}/overrides", consumes = MediaType.APPLICATION_JSON_VALUE)
    public FoodLogEnvelope override(
            @PathVariable String id,
            @RequestBody FoodLogOverrideRequest body,
            HttpServletRequest req
    ) {
        Long uid = auth.requireUserId();
        String requestId = RequestIdFilter.getOrCreate(req);
        return overrideService.applyOverride(uid, id, body, requestId);
    }
}
package com.calai.backend.foodlog.controller;

import com.calai.backend.auth.security.AuthContext;
import com.calai.backend.common.web.RequestIdFilter;
import com.calai.backend.foodlog.service.FoodLogService;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.http.CacheControl;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.StreamingResponseBody;

import java.io.InputStream;
import java.util.concurrent.TimeUnit;

@RequiredArgsConstructor
@ConditionalOnProperty(prefix = "app.features", name = "dev-image-endpoint", havingValue = "true")
@RestController
public class FoodLogImageController {

    private final AuthContext auth;
    private final FoodLogService service;

    @GetMapping("/api/v1/food-logs/{id}/image")
    public ResponseEntity<StreamingResponseBody> image(
            @PathVariable("id") String foodLogId,
            HttpServletRequest req
    ) {
        Long uid = auth.requireUserId();
        String requestId = RequestIdFilter.getOrCreate(req);

        // 1) 查出 objectKey / contentType / size
        var opened = service.openImage(uid, foodLogId);

        // 2) 串流回傳（StreamingResponseBody 會在完成後關閉輸出）
        StreamingResponseBody body = outputStream -> {
            try (InputStream in = service.openImageStream(opened.objectKey())) {
                byte[] buf = new byte[8192];
                int n;
                while ((n = in.read(buf)) >= 0) {
                    outputStream.write(buf, 0, n);
                }
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        };

        HttpHeaders headers = new HttpHeaders();
        String ct = (opened.contentType() == null || opened.contentType().isBlank())
                ? MediaType.APPLICATION_OCTET_STREAM_VALUE
                : opened.contentType();
        headers.set(HttpHeaders.CONTENT_TYPE, ct);

        // 若你希望更保守（避免被第三方代理快取），改成 CacheControl.noStore()
        headers.setCacheControl(CacheControl.maxAge(60, TimeUnit.SECONDS).cachePrivate());

        // 有 size 就給 Content-Length（有助於 App 顯示 loading）
        if (opened.sizeBytes() > 0) headers.setContentLength(opened.sizeBytes());

        // trace（你想也可放 header，這裡先不放避免污染）
        return ResponseEntity.ok()
                .headers(headers)
                .body(body);
    }
}
package com.calai.backend.foodlog.crypto;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.SecureRandom;
import java.util.Base64;

public final class AesGcmCrypto {

    private static final int IV_BYTES = 12;
    private static final int TAG_BITS = 128;

    private final SecretKey key;
    private final SecureRandom random = new SecureRandom();

    /**
     * @param keyBase64 32 bytes(建議) 的 base64；例如用 KMS/SecretManager 發 32 bytes key
     */
    public AesGcmCrypto(String keyBase64) {
        byte[] raw = Base64.getDecoder().decode(keyBase64);
        this.key = new SecretKeySpec(raw, "AES");
    }

    public String encryptToBase64(String plain) {
        try {
            byte[] iv = new byte[IV_BYTES];
            random.nextBytes(iv);

            Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
            c.init(Cipher.ENCRYPT_MODE, key, new GCMParameterSpec(TAG_BITS, iv));

            byte[] ct = c.doFinal(plain.getBytes(java.nio.charset.StandardCharsets.UTF_8));

            byte[] out = new byte[iv.length + ct.length];
            System.arraycopy(iv, 0, out, 0, iv.length);
            System.arraycopy(ct, 0, out, iv.length, ct.length);

            return Base64.getEncoder().encodeToString(out);
        } catch (Exception e) {
            throw new IllegalStateException("CRYPTO_ENCRYPT_FAILED", e);
        }
    }

    public String decryptFromBase64(String cipherB64) {
        try {
            byte[] all = Base64.getDecoder().decode(cipherB64);
            if (all.length <= IV_BYTES) throw new IllegalArgumentException("CRYPTO_BAD_CIPHER");

            byte[] iv = new byte[IV_BYTES];
            byte[] ct = new byte[all.length - IV_BYTES];
            System.arraycopy(all, 0, iv, 0, IV_BYTES);
            System.arraycopy(all, IV_BYTES, ct, 0, ct.length);

            Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
            c.init(Cipher.DECRYPT_MODE, key, new GCMParameterSpec(TAG_BITS, iv));

            byte[] pt = c.doFinal(ct);
            return new String(pt, java.nio.charset.StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new IllegalStateException("CRYPTO_DECRYPT_FAILED", e);
        }
    }
}
package com.calai.backend.foodlog.crypto;

import org.springframework.boot.context.properties.ConfigurationProperties;

/**
 * app.crypto.aesgcm.*
 */
@ConfigurationProperties(prefix = "app.crypto.aesgcm")
public class AesGcmProperties {

    /**
     * Base64 encoded AES key (建議 32 bytes -> base64 44 chars)
     */
    private String keyB64;

    public String getKeyB64() {
        return keyB64;
    }

    public void setKeyB64(String keyB64) {
        this.keyB64 = keyB64;
    }
}
package com.calai.backend.foodlog.crypto;

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableConfigurationProperties(AesGcmProperties.class)
public class CryptoConfig {

    /**
     * 只有在 LOGMEAL provider 才需要 AES-GCM（用來加解密 per-user api token）
     */
    @Bean
    @ConditionalOnProperty(name = "app.foodlog.provider", havingValue = "LOGMEAL")
    public AesGcmCrypto aesGcmCrypto(AesGcmProperties props) {
        String keyB64 = props.getKeyB64();
        if (keyB64 == null || keyB64.isBlank()) {
            // ✅ 這個錯誤會比 PlaceholderResolutionException 友善很多
            throw new IllegalStateException(
                    "Missing app.crypto.aesgcm.key-b64. " +
                    "Set env APP_CRYPTO_AESGCM_KEY_B64 (base64-encoded AES key)."
            );
        }
        return new AesGcmCrypto(keyB64);
    }
}
package com.calai.backend.foodlog.dto;

import com.fasterxml.jackson.annotation.JsonInclude;

@JsonInclude(JsonInclude.Include.NON_NULL)
public record FoodLogEnvelope(
        String foodLogId,
        String status,
        String degradeLevel,
        NutritionResult nutritionResult,
        Task task,
        ApiError error,
        Trace trace
) {
    public record NutritionResult(
            String foodName,
            Quantity quantity,
            Nutrients nutrients,
            Integer healthScore,
            Double confidence,
            Source source
    ) {}

    public record Quantity(Double value, String unit) {}
    public record Nutrients(Double kcal, Double protein, Double fat, Double carbs, Double fiber, Double sugar, Double sodium) {}
    public record Source(String method, String provider) {}

    public record Task(String taskId, Integer pollAfterSec) {}
    public record ApiError(String errorCode, String clientAction, Integer retryAfterSec) {}
    public record Trace(String requestId) {}
}

package com.calai.backend.foodlog.dto;

import com.fasterxml.jackson.annotation.JsonInclude;

@JsonInclude(JsonInclude.Include.NON_NULL)
public record FoodLogErrorResponse(
        String code,
        String message,
        String requestId,
        String clientAction,
        Integer retryAfterSec
) {}
package com.calai.backend.foodlog.dto;

import java.util.Locale;

public enum FoodLogFieldKey {
    FOOD_NAME,
    QUANTITY,
    NUTRIENTS,
    HEALTH_SCORE;

    public static FoodLogFieldKey parse(String raw) {
        if (raw == null) return null;
        String v = raw.trim().toUpperCase(Locale.ROOT);
        try {
            return FoodLogFieldKey.valueOf(v);
        } catch (Exception e) {
            return null;
        }
    }
}
package com.calai.backend.foodlog.dto;

import java.util.List;

public record FoodLogListResponse(
        List<Item> items,
        Page page,
        FoodLogEnvelope.Trace trace
) {
    public record Item(
            String foodLogId,
            String status,
            String capturedLocalDate, // yyyy-MM-dd
            String capturedAtUtc,     // ISO-8601
            Nutrition nutrition
    ) {}

    public record Nutrition(
            String foodName,
            Double kcal,
            Double protein,
            Double fat,
            Double carbs
    ) {}

    public record Page(
            int page,
            int size,
            long totalElements,
            int totalPages
    ) {}
}
package com.calai.backend.foodlog.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.JsonNode;

@JsonInclude(JsonInclude.Include.NON_NULL)
public record FoodLogOverrideRequest(
        String fieldKey,
        JsonNode newValue,
        String reason
) {}
package com.calai.backend.foodlog.dto;

/**
 * PENDING：AI 還在跑（或排隊）
 * DRAFT：AI 給了結果，但使用者可能要改（份量、食物名、營養數值）
 * SAVED：使用者按下「保存」後，才算正式計入日彙總/統計
 * FAILED：provider 失敗，給 retry（或提示使用者重試/改用其他入口）
 * DELETED：使用者刪除或系統刪除
 */
public enum FoodLogStatus {
    PENDING, DRAFT, SAVED, FAILED, DELETED
}
package com.calai.backend.foodlog.dto;

public enum TimeSource {
    EXIF, DEVICE_CLOCK, SERVER_RECEIVED
}
package com.calai.backend.foodlog.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;
import java.util.UUID;

@Getter
@Setter
@Entity
@Table(
        name = "deletion_jobs",
        indexes = {
                @Index(name = "idx_deletion_jobs_food_log_id", columnList = "food_log_id"),
                @Index(name = "idx_deletion_jobs_status", columnList = "job_status,next_retry_at_utc")
        }
)
public class DeletionJobEntity {

    public enum JobStatus { QUEUED, RUNNING, SUCCEEDED, FAILED, CANCELLED }

    @Id
    @Column(length = 36, nullable = false)
    private String id;

    @Column(name = "food_log_id", length = 36, nullable = false)
    private String foodLogId;

    @Column(name = "user_id", nullable = false)
    private Long userId;

    @Column(length = 64)
    private String sha256;

    @Column(length = 8)
    private String ext;

    @Enumerated(EnumType.STRING)
    @Column(name = "job_status", length = 16, nullable = false)
    private JobStatus jobStatus;

    @Column(nullable = false)
    private int attempts = 0;

    @Column(name = "next_retry_at_utc")
    private Instant nextRetryAtUtc;

    @Column(name = "image_object_key", columnDefinition = "TEXT")
    private String imageObjectKey;

    @Column(name = "last_error", columnDefinition = "TEXT")
    private String lastError;

    @Column(name = "created_at_utc", nullable = false)
    private Instant createdAtUtc;

    @Column(name = "updated_at_utc", nullable = false)
    private Instant updatedAtUtc;

    @PrePersist
    void prePersist() {
        if (id == null || id.isBlank()) id = UUID.randomUUID().toString();
        Instant now = Instant.now();
        if (createdAtUtc == null) createdAtUtc = now;
        if (updatedAtUtc == null) updatedAtUtc = now;
        if (jobStatus == null) jobStatus = JobStatus.QUEUED;
    }

    @PreUpdate
    void preUpdate() {
        updatedAtUtc = Instant.now();
    }

    public void markRunning(Instant now) {
        this.jobStatus = JobStatus.RUNNING;
        this.attempts += 1;
        this.updatedAtUtc = now;
    }

    public void markSucceeded(Instant now) {
        this.jobStatus = JobStatus.SUCCEEDED;
        this.nextRetryAtUtc = null;
        this.lastError = null;
        this.updatedAtUtc = now;
    }

    public void markFailed(Instant now, String err, int retryAfterSec) {
        this.jobStatus = JobStatus.FAILED;
        this.lastError = err;
        this.nextRetryAtUtc = now.plusSeconds(retryAfterSec);
        this.updatedAtUtc = now;
    }

    public void markCancelled(Instant now, String err) {
        this.jobStatus = JobStatus.CANCELLED;
        this.lastError = err;
        this.nextRetryAtUtc = null;
        this.updatedAtUtc = now;
    }
}
package com.calai.backend.foodlog.entity;


import com.calai.backend.foodlog.dto.FoodLogStatus;
import com.calai.backend.foodlog.dto.TimeSource;
import com.fasterxml.jackson.databind.JsonNode;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;
import com.fasterxml.jackson.databind.node.JsonNodeFactory;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.time.Instant;
import java.time.LocalDate;
import java.util.Map;
import java.util.UUID;

@Getter
@Setter
@Entity
@Table(name = "food_logs")
public class FoodLogEntity {

    @Id
    @Column(length = 36, nullable = false)
    private String id;

    @Column(name = "user_id", nullable = false)
    private Long userId;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 16)
    private FoodLogStatus status;

    @Column(nullable = false, length = 16)
    private String method;

    @Column(nullable = false, length = 32)
    private String provider;

    @Column(name = "degrade_level", length = 8)
    private String degradeLevel;

    @Column(name = "captured_at_utc", nullable = false)
    private Instant capturedAtUtc;

    @Column(name = "captured_tz", nullable = false, length = 64)
    private String capturedTz;

    @Column(name = "captured_local_date", nullable = false)
    private LocalDate capturedLocalDate;

    @Column(name = "server_received_at_utc", nullable = false)
    private Instant serverReceivedAtUtc;

    @Enumerated(EnumType.STRING)
    @Column(name = "time_source", nullable = false, length = 16)
    private TimeSource timeSource;

    @Column(name = "time_suspect", nullable = false)
    private boolean timeSuspect;

    @Column(name = "image_object_key", columnDefinition = "TEXT")
    private String imageObjectKey;

    @Column(name = "image_sha256", length = 64)
    private String imageSha256;

    @Column(name = "image_content_type", length = 64)
    private String imageContentType;

    @Column(name = "image_size_bytes")
    private Long imageSizeBytes;

    @Column(name = "barcode", length = 64)
    private String barcode;

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "effective", columnDefinition = "JSON")
    private JsonNode effective;

    @Column(name = "last_error_code", length = 64)
    private String lastErrorCode;

    @Column(name = "last_error_message", columnDefinition = "TEXT")
    private String lastErrorMessage;

    @Column(name = "deleted_by", length = 16)
    private String deletedBy;

    @Column(name = "deleted_at_utc")
    private Instant deletedAtUtc;

    @Column(name = "created_at_utc", nullable = false)
    private Instant createdAtUtc;

    @Column(name = "updated_at_utc", nullable = false)
    private Instant updatedAtUtc;

    @PrePersist
    void prePersist() {
        if (id == null || id.isBlank()) id = UUID.randomUUID().toString();
        Instant now = Instant.now();
        if (createdAtUtc == null) createdAtUtc = now;
        if (updatedAtUtc == null) updatedAtUtc = now;
    }

    @PreUpdate
    void preUpdate() {
        updatedAtUtc = Instant.now();
    }

    public void applyEffectivePatch(String fieldKey, JsonNode newValue) {
        ObjectNode root;
        if (this.effective == null || this.effective.isNull() || !this.effective.isObject()) {
            root = JsonNodeFactory.instance.objectNode();
        } else {
            root = this.effective.deepCopy();
        }

        switch (fieldKey) {
            case "FOOD_NAME" -> {
                if (newValue == null || newValue.isNull()) root.remove("foodName");
                else root.set("foodName", newValue);
            }
            case "QUANTITY" -> {
                if (newValue == null || newValue.isNull()) root.remove("quantity");
                else root.set("quantity", newValue);
            }
            case "HEALTH_SCORE" -> {
                if (newValue == null || newValue.isNull()) root.remove("healthScore");
                else root.set("healthScore", newValue);
            }
            case "NUTRIENTS" -> {
                if (newValue == null || newValue.isNull()) {
                    root.remove("nutrients");
                } else {
                    ObjectNode merged;

                    JsonNode existing = root.get("nutrients");
                    if (existing != null && existing.isObject()) {
                        // ✅ 不需要 (ObjectNode) cast
                        merged = existing.deepCopy();
                    } else {
                        merged = JsonNodeFactory.instance.objectNode();
                    }

                    if (!newValue.isObject()) {
                        throw new IllegalArgumentException("OVERRIDE_VALUE_INVALID");
                    }

                    // ✅ Jackson 新版建議用 properties() 取代 fields()
                    for (Map.Entry<String, JsonNode> e : newValue.properties()) {
                        merged.set(e.getKey(), e.getValue());
                    }

                    root.set("nutrients", merged);
                }
            }
            default -> throw new IllegalArgumentException("FIELD_KEY_INVALID");
        }

        this.effective = root;
    }
}
package com.calai.backend.foodlog.entity;

import com.fasterxml.jackson.databind.JsonNode;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.time.Instant;
import java.util.UUID;

@Getter
@Setter
@Entity
@Table(name = "food_log_overrides",
        indexes = @Index(name = "idx_food_log_overrides_log", columnList = "food_log_id,edited_at_utc")
)
public class FoodLogOverrideEntity {

    @Id
    @Column(length = 36, nullable = false)
    private String id;

    @Column(name = "food_log_id", length = 36, nullable = false)
    private String foodLogId;

    @Column(name = "field_key", length = 32, nullable = false)
    private String fieldKey;

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "old_value_json", columnDefinition = "JSON")
    private JsonNode oldValueJson;

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "new_value_json", columnDefinition = "JSON", nullable = false)
    private JsonNode newValueJson;

    @Column(name = "editor_type", length = 16, nullable = false)
    private String editorType; // USER/ADMIN/SYSTEM

    @Column(name = "reason", columnDefinition = "TEXT")
    private String reason;

    @Column(name = "edited_at_utc", nullable = false)
    private Instant editedAtUtc;

    @PrePersist
    void prePersist() {
        if (id == null || id.isBlank()) id = UUID.randomUUID().toString();
        if (editedAtUtc == null) editedAtUtc = Instant.now();
    }

    public static FoodLogOverrideEntity create(
            String foodLogId,
            String fieldKey,
            JsonNode oldValue,
            JsonNode newValue,
            String editorType,
            String reason,
            Instant editedAtUtc
    ) {
        FoodLogOverrideEntity e = new FoodLogOverrideEntity();
        e.foodLogId = foodLogId;
        e.fieldKey = fieldKey;
        e.oldValueJson = oldValue;
        e.newValueJson = newValue;
        e.editorType = editorType;
        e.reason = reason;
        e.editedAtUtc = editedAtUtc;
        return e;
    }
}
package com.calai.backend.foodlog.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(
        name = "food_log_requests",
        uniqueConstraints = @UniqueConstraint(
                name = "uk_food_log_requests_user_req",
                columnNames = {"user_id", "request_id"}
        ),
        indexes = @Index(name = "idx_food_log_requests_log", columnList = "food_log_id")
)
public class FoodLogRequestEntity {

    public enum ReqStatus { RESERVED, ATTACHED, FAILED }

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "user_id", nullable = false)
    private Long userId;

    @Column(name = "request_id", length = 64, nullable = false)
    private String requestId;

    @Column(name = "food_log_id", length = 36)
    private String foodLogId;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 16)
    private ReqStatus status = ReqStatus.RESERVED;

    @Column(name = "error_code", length = 64)
    private String errorCode;

    @Column(name = "error_message", columnDefinition = "TEXT")
    private String errorMessage;

    @Column(name = "created_at_utc", nullable = false)
    private Instant createdAtUtc;

    @Column(name = "updated_at_utc", nullable = false)
    private Instant updatedAtUtc;

    @PrePersist
    void prePersist() {
        Instant now = Instant.now();
        if (createdAtUtc == null) createdAtUtc = now;
        if (updatedAtUtc == null) updatedAtUtc = now;
        if (status == null) status = ReqStatus.RESERVED;
    }

    @PreUpdate
    void preUpdate() {
        updatedAtUtc = Instant.now();
    }
}
package com.calai.backend.foodlog.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import java.time.Instant;
import java.util.UUID;

@Getter
@Setter
@Entity
@Table(name = "food_log_tasks",
        uniqueConstraints = @UniqueConstraint(name = "ux_food_log_tasks_food_log_id", columnNames = "food_log_id"),
        indexes = @Index(name = "idx_food_log_tasks_status", columnList = "task_status,next_retry_at_utc")
)
public class FoodLogTaskEntity {

    public enum TaskStatus { QUEUED, RUNNING, SUCCEEDED, FAILED, CANCELLED }

    @Id
    @Column(length = 36, nullable = false)
    private String id;

    @Column(name = "food_log_id", length = 36, nullable = false)
    private String foodLogId;

    @Enumerated(EnumType.STRING)
    @Column(name = "task_status", length = 16, nullable = false)
    private TaskStatus taskStatus;

    @Column(nullable = false)
    private int attempts = 0;

    @Column(name = "next_retry_at_utc")
    private Instant nextRetryAtUtc;

    @Column(name = "poll_after_sec", nullable = false)
    private int pollAfterSec = 2;

    @Column(name = "last_error_code", length = 64)
    private String lastErrorCode;

    @Column(name = "last_error_message", columnDefinition = "TEXT")
    private String lastErrorMessage;

    @Column(name = "created_at_utc", nullable = false)
    private Instant createdAtUtc;

    @Column(name = "updated_at_utc", nullable = false)
    private Instant updatedAtUtc;

    @PrePersist
    void prePersist() {
        if (id == null || id.isBlank()) id = UUID.randomUUID().toString();
        Instant now = Instant.now();
        if (createdAtUtc == null) createdAtUtc = now;
        if (updatedAtUtc == null) updatedAtUtc = now;
        if (taskStatus == null) taskStatus = TaskStatus.QUEUED;
    }

    @PreUpdate
    void preUpdate() {
        updatedAtUtc = Instant.now();
    }

    public void markRunning(Instant now) {
        this.taskStatus = TaskStatus.RUNNING;
        this.attempts += 1;
        this.updatedAtUtc = now;
    }

    public void markSucceeded(Instant now) {
        this.taskStatus = TaskStatus.SUCCEEDED;
        this.nextRetryAtUtc = null;
        this.updatedAtUtc = now;
    }

    public void markFailed(Instant now, String code, String message, int retryAfterSec) {
        this.taskStatus = TaskStatus.FAILED;
        this.lastErrorCode = code;
        this.lastErrorMessage = message;
        this.nextRetryAtUtc = now.plusSeconds(retryAfterSec);
        this.updatedAtUtc = now;
    }

    /** ✅ 明確取消：不再重試 */
    public void markCancelled(Instant now, String code, String message) {
        this.taskStatus = TaskStatus.CANCELLED;
        this.lastErrorCode = code;
        this.lastErrorMessage = message;
        this.nextRetryAtUtc = null;
        this.updatedAtUtc = now;
    }
}
package com.calai.backend.foodlog.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(
        name = "image_blobs",
        uniqueConstraints = @UniqueConstraint(name = "uk_image_blobs_user_sha", columnNames = {"user_id", "sha256"}),
        indexes = @Index(name = "idx_image_blobs_user", columnList = "user_id")
)
public class ImageBlobEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name="user_id", nullable=false)
    private Long userId;

    @Column(length = 64, nullable=false)
    private String sha256;

    @Column(name="object_key", columnDefinition = "TEXT", nullable=false)
    private String objectKey;

    @Column(name="content_type", length=64, nullable=false)
    private String contentType;

    @Column(name="size_bytes", nullable=false)
    private Long sizeBytes;

    @Column(length=8, nullable=false)
    private String ext;

    @Column(name="ref_count", nullable=false)
    private Integer refCount = 1;

    @Column(name="created_at_utc", nullable=false)
    private Instant createdAtUtc;

    @Column(name="updated_at_utc", nullable=false)
    private Instant updatedAtUtc;

    @PrePersist
    void prePersist() {
        Instant now = Instant.now();
        if (createdAtUtc == null) createdAtUtc = now;
        if (updatedAtUtc == null) updatedAtUtc = now;
        if (refCount == null) refCount = 1;
    }

    @PreUpdate
    void preUpdate() {
        updatedAtUtc = Instant.now();
    }
}
package com.calai.backend.foodlog.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(
        name = "logmeal_accounts",
        uniqueConstraints = @UniqueConstraint(name = "uk_logmeal_accounts_user", columnNames = "user_id"),
        indexes = @Index(name = "idx_logmeal_accounts_status", columnList = "status")
)
public class LogMealAccountEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name="user_id", nullable=false)
    private Long userId;

    @Column(name="api_user_token_enc", columnDefinition = "TEXT", nullable=false)
    private String apiUserTokenEnc;

    @Column(length = 16, nullable=false)
    private String status = "ACTIVE";

    @Column(name="created_at_utc", nullable=false)
    private Instant createdAtUtc;

    @Column(name="updated_at_utc", nullable=false)
    private Instant updatedAtUtc;

    @PrePersist
    void prePersist() {
        Instant now = Instant.now();
        if (createdAtUtc == null) createdAtUtc = now;
        if (updatedAtUtc == null) updatedAtUtc = now;
        if (status == null) status = "ACTIVE";
    }

    @PreUpdate
    void preUpdate() {
        updatedAtUtc = Instant.now();
    }
}
package com.calai.backend.foodlog.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;
import java.time.LocalDate;

@Getter
@Setter
@Entity
@Table(name = "usage_counters",
        uniqueConstraints = @UniqueConstraint(name = "uk_usage_counters_user_date", columnNames = {"user_id","local_date"}),
        indexes = @Index(name = "idx_usage_counters_user_date", columnList = "user_id,local_date")
)
public class UsageCounterEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "user_id", nullable = false)
    private Long userId;

    @Column(name = "local_date", nullable = false)
    private LocalDate localDate;

    @Column(name = "used_count", nullable = false)
    private int usedCount = 0;

    @Column(name = "updated_at_utc", nullable = false)
    private Instant updatedAtUtc;

    @PrePersist
    void prePersist() {
        if (updatedAtUtc == null) updatedAtUtc = Instant.now();
    }

    @PreUpdate
    void preUpdate() {
        updatedAtUtc = Instant.now();
    }
}
package com.calai.backend.foodlog.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;
import java.util.UUID;

@Getter
@Setter
@Entity
@Table(name = "user_entitlements",
        indexes = @Index(name = "idx_entitlements_user", columnList = "user_id,status,valid_to_utc")
)
public class UserEntitlementEntity {

    @Id
    @Column(length = 36, nullable = false)
    private String id;

    @Column(name = "user_id", nullable = false)
    private Long userId;

    @Column(name = "entitlement_type", length = 16, nullable = false)
    private String entitlementType; // TRIAL/MONTHLY/YEARLY

    @Column(length = 16, nullable = false)
    private String status; // ACTIVE/EXPIRED/CANCELLED

    @Column(name = "valid_from_utc", nullable = false)
    private Instant validFromUtc;

    @Column(name = "valid_to_utc", nullable = false)
    private Instant validToUtc;

    @Column(name = "purchase_token_hash", length = 64)
    private String purchaseTokenHash;

    @Column(name = "last_verified_at_utc")
    private Instant lastVerifiedAtUtc;

    @Column(name = "created_at_utc", nullable = false)
    private Instant createdAtUtc;

    @Column(name = "updated_at_utc", nullable = false)
    private Instant updatedAtUtc;

    @PrePersist
    void prePersist() {
        if (id == null || id.isBlank()) id = UUID.randomUUID().toString();
        Instant now = Instant.now();
        if (createdAtUtc == null) createdAtUtc = now;
        if (updatedAtUtc == null) updatedAtUtc = now;
    }

    @PreUpdate
    void preUpdate() {
        updatedAtUtc = Instant.now();
    }
}
package com.calai.backend.foodlog.image;

import java.io.IOException;
import java.io.PushbackInputStream;
import java.util.Arrays;

public final class ImageSniffer {

    private ImageSniffer() {}

    public enum ImageType {
        JPEG("image/jpeg", ".jpg"),
        PNG("image/png", ".png");

        private final String contentType;
        private final String ext;

        ImageType(String contentType, String ext) {
            this.contentType = contentType;
            this.ext = ext;
        }

        public String contentType() { return contentType; }
        public String ext() { return ext; }
    }

    public record Detection(ImageType type) {
        public String contentType() { return type.contentType(); }
        public String ext() { return type.ext(); }
    }

    private static final byte[] PNG_SIG = new byte[] {
            (byte) 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A
    };

    /**
     * 會讀取最多 16 bytes 作判斷，然後 push back 回去（不影響後續存檔）
     */
    public static Detection detect(PushbackInputStream in) throws IOException {
        byte[] head = new byte[16];
        int n = in.read(head);
        if (n <= 0) return null;

        // push back：後續 storage.save() 要能讀到完整檔案
        in.unread(head, 0, n);

        // PNG：前 8 bytes signature
        if (n >= 8 && startsWith(head, n, PNG_SIG)) {
            return new Detection(ImageType.PNG);
        }

        // JPEG：FF D8 FF
        if (n >= 3 && (head[0] == (byte) 0xFF) && (head[1] == (byte) 0xD8) && (head[2] == (byte) 0xFF)) {
            return new Detection(ImageType.JPEG);
        }

        return null;
    }

    private static boolean startsWith(byte[] buf, int n, byte[] prefix) {
        if (n < prefix.length) return false;
        return Arrays.equals(Arrays.copyOfRange(buf, 0, prefix.length), prefix);
    }
}
package com.calai.backend.foodlog.provider;

import org.springframework.boot.context.properties.ConfigurationProperties;

import java.time.Duration;

@ConfigurationProperties(prefix = "app.provider.logmeal")
public record LogMealProperties(
        String baseUrl,
        Duration connectTimeout,
        Duration readTimeout,
        String authorizationPrefix
) {
    public Duration connectTimeoutOrDefault() {
        return connectTimeout != null ? connectTimeout : Duration.ofSeconds(5);
    }

    public Duration readTimeoutOrDefault() {
        return readTimeout != null ? readTimeout : Duration.ofSeconds(25);
    }

    public String authorizationPrefixOrDefault() {
        // 有些服務要 "Bearer"，有些是直接 token；留給設定決定
        return authorizationPrefix;
    }
}
package com.calai.backend.foodlog.provider;

import com.calai.backend.foodlog.entity.FoodLogEntity;
import com.calai.backend.foodlog.service.LogMealTokenService;
import com.calai.backend.foodlog.storage.StorageService;
import com.calai.backend.foodlog.task.ProviderClient;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.JsonNodeFactory;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestClient;

import java.io.InputStream;

public class LogMealProviderClient implements ProviderClient {

    private final RestClient http;
    private final LogMealProperties props;
    private final LogMealTokenService tokenService;
    private final ObjectMapper om = new ObjectMapper();

    public LogMealProviderClient(RestClient http, LogMealProperties props, LogMealTokenService tokenService) {
        this.http = http;
        this.props = props;
        this.tokenService = tokenService;
    }

    @Override
    public ProviderResult process(FoodLogEntity log, StorageService storage) throws Exception {
        byte[] bytes;
        try (InputStream in = storage.open(log.getImageObjectKey()).inputStream()) {
            bytes = in.readAllBytes();
        }
        if (bytes.length == 0) throw new IllegalStateException("EMPTY_IMAGE");

        // ✅ per-user token
        String apiUserToken = tokenService.requireApiUserToken(log.getUserId());
        String authHeader = buildAuthHeader(apiUserToken);

        String imageId = callSegmentationComplete(bytes, authHeader);
        JsonNode intake = callGetIntake(imageId, authHeader);

        ObjectNode effective = mapToEffective(intake);
        effective.putPOJO("confidence", guessConfidence(intake));

        return new ProviderResult(effective, "LOGMEAL");
    }

    private String buildAuthHeader(String token) {
        // 讓你可配置 prefix（有些服務要 Bearer，有些不用）
        String prefix = props.authorizationPrefixOrDefault(); // 你在 LogMealProperties 加這個 getter
        if (prefix == null || prefix.isBlank()) return token;
        return prefix.trim() + " " + token;
    }

    private String callSegmentationComplete(byte[] bytes, String authHeader) {
        MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();

        ByteArrayResource file = new ByteArrayResource(bytes) {
            @Override public String getFilename() { return "upload.jpg"; }
        };
        body.add("image", file);

        JsonNode resp = http.post()
                .uri("/v2/image/segmentation/complete")
                .header(HttpHeaders.AUTHORIZATION, authHeader)
                .contentType(MediaType.MULTIPART_FORM_DATA)
                .body(body)
                .retrieve()
                .body(JsonNode.class);

        String imageId = text(resp, "imageId");
        if (imageId == null) imageId = text(resp, "id");
        if (imageId == null) throw new IllegalStateException("LOGMEAL_IMAGE_ID_MISSING");
        return imageId;
    }

    private JsonNode callGetIntake(String imageId, String authHeader) {
        JsonNode resp = http.get()
                .uri("/v2/intake/{imageId}", imageId)
                .header(HttpHeaders.AUTHORIZATION, authHeader)
                .retrieve()
                .body(JsonNode.class);
        if (resp == null || resp.isNull()) throw new IllegalStateException("LOGMEAL_INTAKE_EMPTY");
        return resp;
    }

    private ObjectNode mapToEffective(JsonNode intake) {
        ObjectNode root = JsonNodeFactory.instance.objectNode();

        String name = null;
        JsonNode dishes0 = intake.path("dishes").path(0);
        if (!dishes0.isMissingNode()) name = dishes0.path("name").asText(null);
        if (name == null) name = intake.path("foodName").asText(null);
        if (name == null) name = intake.path("title").asText(null);
        root.put("foodName", name);

        ObjectNode q = root.putObject("quantity");
        q.put("value", 1d);
        q.put("unit", "SERVING");

        ObjectNode n = root.putObject("nutrients");
        n.putPOJO("kcal", firstNumber(intake, "nutrients.kcal", "nutrition.kcal", "calories"));
        n.putPOJO("protein", firstNumber(intake, "nutrients.protein", "nutrition.protein"));
        n.putPOJO("fat", firstNumber(intake, "nutrients.fat", "nutrition.fat"));
        n.putPOJO("carbs", firstNumber(intake, "nutrients.carbs", "nutrition.carbs"));

        return root;
    }

    private Double firstNumber(JsonNode root, String... paths) {
        for (String p : paths) {
            JsonNode v = at(root, p);
            if (v != null && v.isNumber()) return v.asDouble();
        }
        return null;
    }

    private JsonNode at(JsonNode root, String dottedPath) {
        JsonNode cur = root;
        for (String part : dottedPath.split("\\.")) {
            if (cur == null) return null;
            cur = cur.path(part);
            if (cur.isMissingNode()) return null;
        }
        return cur;
    }

    private static String text(JsonNode node, String field) {
        if (node == null) return null;
        JsonNode v = node.get(field);
        return (v == null || v.isNull()) ? null : v.asText(null);
    }

    private Double guessConfidence(JsonNode intake) {
        JsonNode v = at(intake, "confidence");
        if (v != null && v.isNumber()) return v.asDouble();
        v = at(intake, "score");
        if (v != null && v.isNumber()) return v.asDouble();
        return null;
    }
}
package com.calai.backend.foodlog.provider;

import com.calai.backend.foodlog.service.LogMealTokenService;
import com.calai.backend.foodlog.task.ProviderClient;
import com.calai.backend.foodlog.task.StubProviderClient;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.web.client.RestClient;

@Configuration
@EnableConfigurationProperties(LogMealProperties.class)
public class ProviderConfig {

    @Bean
    public RestClient logMealRestClient(LogMealProperties props) {
        SimpleClientHttpRequestFactory f = new SimpleClientHttpRequestFactory();
        f.setConnectTimeout((int) props.connectTimeoutOrDefault().toMillis());
        f.setReadTimeout((int) props.readTimeoutOrDefault().toMillis());

        // ✅ 這裡修正：RestClient.builder()
        return RestClient.builder()
                .baseUrl(props.baseUrl())
                .requestFactory(f)
                .build();
    }

    @Bean
    @ConditionalOnProperty(name = "app.foodlog.provider", havingValue = "LOGMEAL")
    public ProviderClient logMealProviderClient(
            RestClient logMealRestClient,
            LogMealProperties props,
            LogMealTokenService tokenService
    ) {
        return new LogMealProviderClient(logMealRestClient, props, tokenService);
    }

    @Bean
    @ConditionalOnProperty(name = "app.foodlog.provider", havingValue = "STUB")
    public ProviderClient stubProviderClient(ObjectMapper om) {
        return new StubProviderClient(om);
    }
}
package com.calai.backend.foodlog.quota;

import java.time.*;

public final class QuotaDayKey {

    private QuotaDayKey() {}

    public static LocalDate todayLocalDate(Instant serverNowUtc, ZoneId userTz) {
        return ZonedDateTime.ofInstant(serverNowUtc, userTz).toLocalDate();
    }
}
package com.calai.backend.foodlog.repo;

import com.calai.backend.foodlog.entity.DeletionJobEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import jakarta.persistence.LockModeType;
import org.springframework.data.jpa.repository.Lock;

import java.time.Instant;
import java.util.List;
import java.util.Optional;

public interface DeletionJobRepository extends JpaRepository<DeletionJobEntity, String> {

    @Query(
            value = """
            SELECT *
            FROM deletion_jobs
            WHERE
                 (job_status = 'QUEUED')
              OR (job_status = 'FAILED'
                  AND next_retry_at_utc IS NOT NULL
                  AND next_retry_at_utc <= :now)
            ORDER BY created_at_utc ASC
            LIMIT :limit
            FOR UPDATE SKIP LOCKED
            """,
            nativeQuery = true
    )
    List<DeletionJobEntity> claimRunnableForUpdate(@Param("now") Instant now, @Param("limit") int limit);

    Optional<DeletionJobEntity> findByFoodLogId(String foodLogId);

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("select j from DeletionJobEntity j where j.foodLogId = :foodLogId")
    Optional<DeletionJobEntity> findByFoodLogIdForUpdate(@Param("foodLogId") String foodLogId);
}
package com.calai.backend.foodlog.repo;

import com.calai.backend.foodlog.entity.FoodLogOverrideEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface FoodLogOverrideRepository extends JpaRepository<FoodLogOverrideEntity, String> {
}
package com.calai.backend.foodlog.repo;

import com.calai.backend.foodlog.dto.FoodLogStatus;
import com.calai.backend.foodlog.entity.FoodLogEntity;
import jakarta.persistence.LockModeType;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Lock;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.repository.query.Param;
import java.util.Optional;
import java.time.LocalDate;

public interface FoodLogRepository extends JpaRepository<FoodLogEntity, String> {
    Optional<FoodLogEntity> findByIdAndUserId(String id, Long userId);

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("select f from FoodLogEntity f where f.id = :id")
    FoodLogEntity findByIdForUpdate(@Param("id") String id);

    Optional<FoodLogEntity> findFirstByUserIdAndImageSha256AndStatusInOrderByCreatedAtUtcDesc(
            Long userId, String imageSha256, java.util.List<FoodLogStatus> status
    );

    @Query("""
        select f from FoodLogEntity f
        where f.userId = :userId
          and f.status = :status
          and f.capturedLocalDate >= :from
          and f.capturedLocalDate <= :to
        order by f.capturedAtUtc desc
    """)
    Page<FoodLogEntity> findByUserIdAndStatusAndCapturedLocalDateRange(
            @Param("userId") Long userId,
            @Param("status") FoodLogStatus status,
            @Param("from") LocalDate from,
            @Param("to") LocalDate to,
            Pageable pageable
    );

    @Query("""
        select count(f) from FoodLogEntity f
        where f.userId = :userId
          and f.imageObjectKey = :objectKey
          and f.status <> :deletedStatus
    """)
    long countLiveRefsByObjectKey(
            @Param("userId") Long userId,
            @Param("objectKey") String objectKey,
            @Param("deletedStatus") FoodLogStatus deletedStatus
    );
}
package com.calai.backend.foodlog.repo;

import com.calai.backend.foodlog.entity.FoodLogRequestEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.time.Instant;

public interface FoodLogRequestRepository extends JpaRepository<FoodLogRequestEntity, Long> {

    @Query(
            value = """
            SELECT food_log_id
            FROM food_log_requests
            WHERE user_id = :userId AND request_id = :requestId
            """,
            nativeQuery = true
    )
    String findFoodLogId(@Param("userId") Long userId, @Param("requestId") String requestId);

    @Query(
            value = """
            SELECT status
            FROM food_log_requests
            WHERE user_id = :userId AND request_id = :requestId
            """,
            nativeQuery = true
    )
    String findStatus(@Param("userId") Long userId, @Param("requestId") String requestId);

    @Modifying
    @Query(
            value = """
            INSERT IGNORE INTO food_log_requests(user_id, request_id, status, created_at_utc, updated_at_utc)
            VALUES (:userId, :requestId, 'RESERVED', :now, :now)
            """,
            nativeQuery = true
    )
    int reserve(@Param("userId") Long userId, @Param("requestId") String requestId, @Param("now") Instant now);

    /** 只有 food_log_id 仍為 NULL 才能 attach（避免競態覆寫） */
    @Modifying
    @Query(
            value = """
            UPDATE food_log_requests
            SET food_log_id = :foodLogId,
                status = 'ATTACHED',
                updated_at_utc = :now
            WHERE user_id = :userId
              AND request_id = :requestId
              AND food_log_id IS NULL
            """,
            nativeQuery = true
    )
    int attach(@Param("userId") Long userId,
               @Param("requestId") String requestId,
               @Param("foodLogId") String foodLogId,
               @Param("now") Instant now);

    @Modifying
    @Query(
            value = """
            UPDATE food_log_requests
            SET status='FAILED',
                error_code=:code,
                error_message=:msg,
                updated_at_utc=:now
            WHERE user_id=:userId AND request_id=:requestId
            """,
            nativeQuery = true
    )
    int markFailed(@Param("userId") Long userId,
                   @Param("requestId") String requestId,
                   @Param("code") String code,
                   @Param("msg") String msg,
                   @Param("now") Instant now);

    /** 失敗時可選擇釋放（讓同 requestId 可重送重做） */
    @Modifying
    @Query(
            value = """
            DELETE FROM food_log_requests
            WHERE user_id=:userId AND request_id=:requestId AND food_log_id IS NULL
            """,
            nativeQuery = true
    )
    int releaseIfNotAttached(@Param("userId") Long userId, @Param("requestId") String requestId);

    @Modifying
    @Query(
            value = """
        DELETE FROM food_log_requests
        WHERE user_id = :userId
          AND request_id = :requestId
          AND status = 'FAILED'
          AND food_log_id IS NULL
        """,
            nativeQuery = true
    )
    int deleteFailedIfNotAttached(@Param("userId") Long userId, @Param("requestId") String requestId);
}
package com.calai.backend.foodlog.repo;

import com.calai.backend.foodlog.entity.FoodLogTaskEntity;
import jakarta.persistence.LockModeType;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.data.jpa.repository.Lock;
import java.time.Instant;
import java.util.List;
import java.util.Optional;

public interface FoodLogTaskRepository extends JpaRepository<FoodLogTaskEntity, String> {

    /**
     * ✅ MySQL 8：用 FOR UPDATE SKIP LOCKED 領取任務，避免多 worker 重複撿同一筆
     * 注意：
     * - 需要在 @Transactional 內呼叫才會真的 lock
     * - SKIP LOCKED 讓其他 worker 不會卡住，會跳過已被鎖住的 rows
     */
    @Query(
            value = """
            SELECT *
            FROM food_log_tasks
            WHERE
                 (task_status = 'QUEUED')
              OR (task_status = 'FAILED'
                  AND next_retry_at_utc IS NOT NULL
                  AND next_retry_at_utc <= :now)
            ORDER BY created_at_utc ASC
            LIMIT :limit
            FOR UPDATE SKIP LOCKED
            """,
            nativeQuery = true
    )
    List<FoodLogTaskEntity> claimRunnableForUpdate(@Param("now") Instant now, @Param("limit") int limit);

    Optional<FoodLogTaskEntity> findByFoodLogId(String foodLogId);

    /** ✅ Step 3.8：手動 retry / worker 競態時需要 */
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("select t from FoodLogTaskEntity t where t.foodLogId = :foodLogId")
    Optional<FoodLogTaskEntity> findByFoodLogIdForUpdate(@Param("foodLogId") String foodLogId);

    @Modifying
    @Query(
            value = """
        UPDATE food_log_tasks t
        JOIN food_logs f ON f.id = t.food_log_id
        SET
            t.task_status = 'FAILED',
            t.next_retry_at_utc = :now,
            t.last_error_code = :code,
            t.last_error_message = :msg,
            t.updated_at_utc = :now,

            f.status = 'FAILED',
            f.last_error_code = :code,
            f.last_error_message = :msg,
            f.updated_at_utc = :now
        WHERE t.task_status = 'RUNNING'
          AND t.updated_at_utc <= :staleBefore
          AND f.status = 'PENDING'
        """,
            nativeQuery = true
    )
    int resetStaleRunningAndMarkLogsFailed(
            @Param("staleBefore") Instant staleBefore,
            @Param("now") Instant now,
            @Param("code") String code,
            @Param("msg") String msg
    );
}
package com.calai.backend.foodlog.repo;

import com.calai.backend.foodlog.entity.ImageBlobEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.time.Instant;
import java.util.Optional;

public interface ImageBlobRepository extends JpaRepository<ImageBlobEntity, Long> {

    Optional<ImageBlobEntity> findByUserIdAndSha256(Long userId, String sha256);

    /** 新 blob：INSERT IGNORE，成功回 1 */
    @Modifying
    @Query(
            value = """
            INSERT IGNORE INTO image_blobs(user_id, sha256, object_key, content_type, size_bytes, ext, ref_count, created_at_utc, updated_at_utc)
            VALUES (:userId, :sha256, :objectKey, :contentType, :sizeBytes, :ext, 1, :now, :now)
            """,
            nativeQuery = true
    )
    int insertFirst(@Param("userId") Long userId,
                    @Param("sha256") String sha256,
                    @Param("objectKey") String objectKey,
                    @Param("contentType") String contentType,
                    @Param("sizeBytes") long sizeBytes,
                    @Param("ext") String ext,
                    @Param("now") Instant now);

    /** 既有 blob：ref_count + 1 */
    @Modifying
    @Query(
            value = """
            UPDATE image_blobs
            SET ref_count = ref_count + 1,
                updated_at_utc = :now
            WHERE user_id = :userId AND sha256 = :sha256
            """,
            nativeQuery = true
    )
    int retain(@Param("userId") Long userId, @Param("sha256") String sha256, @Param("now") Instant now);

    /** release：ref_count - 1（不讓它變負） */
    @Modifying
    @Query(
            value = """
            UPDATE image_blobs
            SET ref_count = CASE WHEN ref_count > 0 THEN ref_count - 1 ELSE 0 END,
                updated_at_utc = :now
            WHERE user_id = :userId AND sha256 = :sha256
            """,
            nativeQuery = true
    )
    int release(@Param("userId") Long userId, @Param("sha256") String sha256, @Param("now") Instant now);

    @Query(
            value = """
            SELECT ref_count FROM image_blobs
            WHERE user_id = :userId AND sha256 = :sha256
            """,
            nativeQuery = true
    )
    Integer getRefCount(@Param("userId") Long userId, @Param("sha256") String sha256);

    @Modifying
    @Query(
            value = """
            DELETE FROM image_blobs
            WHERE user_id = :userId AND sha256 = :sha256 AND ref_count <= 0
            """,
            nativeQuery = true
    )
    int deleteIfZero(@Param("userId") Long userId, @Param("sha256") String sha256);
}
package com.calai.backend.foodlog.repo;

import com.calai.backend.foodlog.entity.LogMealAccountEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface LogMealAccountRepository extends JpaRepository<LogMealAccountEntity, Long> {
    Optional<LogMealAccountEntity> findByUserId(Long userId);
}
package com.calai.backend.foodlog.repo;

import com.calai.backend.foodlog.entity.UsageCounterEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.time.Instant;
import java.time.LocalDate;

public interface UsageCounterRepository extends JpaRepository<UsageCounterEntity, Long> {

    /** row 不存在就插入 used_count=1；存在則 0 rows */
    @Modifying
    @Query(
            value = """
        INSERT IGNORE INTO usage_counters(user_id, local_date, used_count, updated_at_utc)
        VALUES (:userId, :localDate, 1, :now)
        """,
            nativeQuery = true
    )
    int insertFirstUse(@Param("userId") Long userId, @Param("localDate") LocalDate localDate, @Param("now") Instant now);

    /** row 存在時才走這個：used_count < limit 才能 +1，否則 0 rows */
    @Modifying
    @Query(
            value = """
        UPDATE usage_counters
        SET used_count = used_count + 1,
            updated_at_utc = :now
        WHERE user_id = :userId
          AND local_date = :localDate
          AND used_count < :limit
        """,
            nativeQuery = true
    )
    int incrementIfBelowLimit(@Param("userId") Long userId, @Param("localDate") LocalDate localDate,
                              @Param("limit") int limit, @Param("now") Instant now);

    @Query(
            value = "SELECT used_count FROM usage_counters WHERE user_id = :userId AND local_date = :localDate",
            nativeQuery = true
    )
    Integer findUsedCount(@Param("userId") Long userId, @Param("localDate") LocalDate localDate);
}
package com.calai.backend.foodlog.repo;


import com.calai.backend.foodlog.entity.UserEntitlementEntity;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.time.Instant;
import java.util.List;

public interface UserEntitlementRepository extends JpaRepository<UserEntitlementEntity, String> {

    @Query("""
        select e from UserEntitlementEntity e
        where e.userId = :userId
          and e.status = 'ACTIVE'
          and e.validFromUtc <= :now
          and e.validToUtc > :now
        order by e.validToUtc desc
    """)
    List<UserEntitlementEntity> findActive(@Param("userId") Long userId, @Param("now") Instant now, Pageable pageable);
}
package com.calai.backend.foodlog.service.cleanup;

import com.calai.backend.foodlog.storage.StorageService;
import lombok.extern.slf4j.Slf4j;

/**
 * 任何 cleanup 都用這支，避免 cleanup 失敗蓋過主要例外。
 */
@Slf4j
public final class StorageCleanup {

    private StorageCleanup() {}

    public static void safeDeleteQuietly(StorageService storage, String objectKey) {
        if (storage == null) return;
        if (objectKey == null || objectKey.isBlank()) return;
        try {
            storage.delete(objectKey);
        } catch (Exception e) {
            log.debug("cleanup delete failed: key={}", objectKey, e);
        }
    }

    /**
     * 如果你真的拿不到 ext（極少），才用這個：同時試 .jpg/.png
     */
    public static void safeDeleteTempUploadFallback(StorageService storage, Long userId, String requestId) {
        if (storage == null) return;
        if (userId == null) return;
        if (requestId == null || requestId.isBlank()) return;

        safeDeleteQuietly(storage, "user-" + userId + "/blobs/tmp/" + requestId + "/upload.jpg");
        safeDeleteQuietly(storage, "user-" + userId + "/blobs/tmp/" + requestId + "/upload.png");
    }
}
package com.calai.backend.foodlog.service.limiter;

import com.calai.backend.foodlog.web.TooManyInFlightException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Semaphore;

/**
 * ✅ MVP 併發防爆：
 * - 每個 userId 對應一個 semaphore
 * - acquire 失敗直接 429，避免你磁碟/CPU 被同一人灌爆
 *
 * 注意：多機部署時是「每台機器各自限制」；要全域需要 Redis/DB。
 */
@Service
public class UserInFlightLimiter {

    private final ConcurrentHashMap<Long, Semaphore> semMap = new ConcurrentHashMap<>();

    private final int maxInFlight;

    public UserInFlightLimiter(@Value("${app.guard.inflight.max:2}") int maxInFlight) {
        this.maxInFlight = Math.max(1, maxInFlight);
    }

    public void acquireOrThrow(Long userId) {
        if (userId == null) return;
        Semaphore sem = semMap.computeIfAbsent(userId, k -> new Semaphore(maxInFlight));
        boolean ok = sem.tryAcquire();
        if (!ok) {
            // 1 秒後再試（App 端可做退避）
            throw new TooManyInFlightException("TOO_MANY_IN_FLIGHT", 1, "RETRY_LATER");
        }
    }

    public void release(Long userId) {
        if (userId == null) return;
        Semaphore sem = semMap.get(userId);
        if (sem != null) sem.release();
    }
}
package com.calai.backend.foodlog.service.limiter;

import com.calai.backend.foodlog.web.RateLimitedException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * ✅ MVP 速率限制（固定視窗 60 秒）
 * - 每個 userId 一個 window
 * - 超過 perMinuteLimit → 429
 *
 * 多機要全域：後續替換成 Redis/Bucket4j 都很容易（把介面保留）。
 */
@Service
public class UserRateLimiter {

    private static final class Window {
        volatile long windowStartEpochSec;
        final AtomicInteger count = new AtomicInteger(0);

        Window(long start) { this.windowStartEpochSec = start; }
    }

    private final ConcurrentHashMap<Long, Window> map = new ConcurrentHashMap<>();
    private final int perMinuteLimit;

    public UserRateLimiter(@Value("${app.guard.rate.per-minute:20}") int perMinuteLimit) {
        this.perMinuteLimit = Math.max(1, perMinuteLimit);
    }

    public void checkOrThrow(Long userId, Instant nowUtc) {
        if (userId == null) return;

        long nowSec = nowUtc.getEpochSecond();
        long start = (nowSec / 60) * 60;

        Window w = map.computeIfAbsent(userId, k -> new Window(start));

        // 進入新分鐘：重置
        if (w.windowStartEpochSec != start) {
            synchronized (w) {
                if (w.windowStartEpochSec != start) {
                    w.windowStartEpochSec = start;
                    w.count.set(0);
                }
            }
        }

        int n = w.count.incrementAndGet();
        if (n > perMinuteLimit) {
            int retryAfter = (int) Math.max(0, (start + 60) - nowSec);
            throw new RateLimitedException("RATE_LIMITED", retryAfter, "RETRY_LATER");
        }
    }
}
package com.calai.backend.foodlog.service;

import com.calai.backend.foodlog.repo.UserEntitlementRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.Locale;

@RequiredArgsConstructor
@Service
public class EntitlementService {

    public enum Tier { NONE, TRIAL, MONTHLY, YEARLY }

    private final UserEntitlementRepository repo;

    public Tier resolveTier(Long userId, Instant nowUtc) {
        var list = repo.findActive(userId, nowUtc, PageRequest.of(0, 5));
        if (list.isEmpty()) return Tier.NONE;

        // 若同時存在，取「最高」：YEARLY > MONTHLY > TRIAL
        Tier best = Tier.NONE;
        for (var e : list) {
            Tier t = parseTier(e.getEntitlementType());
            if (rank(t) > rank(best)) best = t;
        }
        return best;
    }

    private static Tier parseTier(String raw) {
        if (raw == null) return Tier.NONE;
        String v = raw.trim().toUpperCase(Locale.ROOT);
        return switch (v) {
            case "TRIAL" -> Tier.TRIAL;
            case "MONTHLY" -> Tier.MONTHLY;
            case "YEARLY" -> Tier.YEARLY;
            default -> Tier.NONE;
        };
    }

    private static int rank(Tier t) {
        return switch (t) {
            case NONE -> 0;
            case TRIAL -> 1;
            case MONTHLY -> 2;
            case YEARLY -> 3;
        };
    }
}
package com.calai.backend.foodlog.service;

import com.calai.backend.foodlog.dto.FoodLogEnvelope;
import com.calai.backend.foodlog.dto.FoodLogStatus;
import com.calai.backend.foodlog.entity.DeletionJobEntity;
import com.calai.backend.foodlog.entity.FoodLogEntity;
import com.calai.backend.foodlog.entity.FoodLogTaskEntity;
import com.calai.backend.foodlog.repo.DeletionJobRepository;
import com.calai.backend.foodlog.repo.FoodLogRepository;
import com.calai.backend.foodlog.repo.FoodLogTaskRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;

@RequiredArgsConstructor
@Service
public class FoodLogDeleteService {

    private final FoodLogRepository logRepo;
    private final FoodLogTaskRepository taskRepo;
    private final DeletionJobRepository deletionRepo;
    private final ImageBlobService blobService;
    private final FoodLogService foodLogService; // 用它的 toEnvelope/getOne（先重用）

    @Transactional
    public FoodLogEnvelope deleteOne(Long userId, String foodLogId, String requestId) {
        Instant now = Instant.now();

        FoodLogEntity log = logRepo.findByIdForUpdate(foodLogId);
        if (!userId.equals(log.getUserId())) throw new IllegalArgumentException("FOOD_LOG_NOT_FOUND");

        // ✅ 冪等刪除：已 DELETED 直接回
        if (log.getStatus() == FoodLogStatus.DELETED) {
            return foodLogService.getOne(userId, foodLogId, requestId);
        }

        // ✅ 先取消 task（更硬一層，避免 worker 競態）
        var optTask = taskRepo.findByFoodLogIdForUpdate(foodLogId);
        if (optTask.isPresent()) {
            FoodLogTaskEntity t = optTask.get();
            if (t.getTaskStatus() == FoodLogTaskEntity.TaskStatus.QUEUED
                || t.getTaskStatus() == FoodLogTaskEntity.TaskStatus.RUNNING
                || t.getTaskStatus() == FoodLogTaskEntity.TaskStatus.FAILED) {
                t.markCancelled(now, "LOG_DELETED", "cancelled by delete");
                taskRepo.save(t);
            }
        }

        // ✅ 設為 DELETED（軟刪）
        log.setStatus(FoodLogStatus.DELETED);
        log.setDeletedAtUtc(now);
        log.setDeletedBy("USER");
        logRepo.save(log);

        // ✅ enqueue deletion job（只要有 sha256 才需要 release blob）
        if (log.getImageSha256() != null && !log.getImageSha256().isBlank()) {
            // ✅ 不要 parse objectKey：ext 從 image_blobs 取（若沒有就給 null，worker 會 CANCELLED）
            String ext = blobService.findExtOrNull(userId, log.getImageSha256());

            DeletionJobEntity job = new DeletionJobEntity();
            job.setFoodLogId(foodLogId);
            job.setUserId(userId);
            job.setSha256(log.getImageSha256());
            job.setExt(ext);
            job.setImageObjectKey(log.getImageObjectKey());
            job.setJobStatus(DeletionJobEntity.JobStatus.QUEUED);
            job.setAttempts(0);
            job.setNextRetryAtUtc(null);
            deletionRepo.save(job);
        }

        return foodLogService.getOne(userId, foodLogId, requestId);
    }
}
package com.calai.backend.foodlog.service;

import com.calai.backend.foodlog.dto.FoodLogEnvelope;
import com.calai.backend.foodlog.dto.FoodLogListResponse;
import com.calai.backend.foodlog.dto.FoodLogStatus;
import com.calai.backend.foodlog.entity.FoodLogEntity;
import com.calai.backend.foodlog.repo.FoodLogRepository;
import com.fasterxml.jackson.databind.JsonNode;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.Locale;

@RequiredArgsConstructor
@Service
public class FoodLogHistoryService {

    private final FoodLogRepository logRepo;
    private final FoodLogService foodLogService;

    @Transactional
    public FoodLogEnvelope save(Long userId, String foodLogId, String requestId) {
        FoodLogEntity log = logRepo.findByIdForUpdate(foodLogId);
        if (!userId.equals(log.getUserId())) throw new IllegalArgumentException("FOOD_LOG_NOT_FOUND");

        if (log.getStatus() == FoodLogStatus.DELETED) throw new IllegalArgumentException("FOOD_LOG_DELETED");
        if (log.getStatus() == FoodLogStatus.SAVED) return foodLogService.getOne(userId, foodLogId, requestId);
        if (log.getStatus() == FoodLogStatus.PENDING) throw new IllegalArgumentException("FOOD_LOG_NOT_READY");
        if (log.getStatus() == FoodLogStatus.FAILED) throw new IllegalArgumentException("FOOD_LOG_FAILED");
        if (log.getStatus() != FoodLogStatus.DRAFT) throw new IllegalArgumentException("FOOD_LOG_NOT_SAVABLE");

        log.setStatus(FoodLogStatus.SAVED);
        logRepo.save(log);
        return foodLogService.getOne(userId, foodLogId, requestId);
    }

    @Transactional(readOnly = true)
    public FoodLogListResponse listSaved(
            Long userId,
            LocalDate fromLocalDate,
            LocalDate toLocalDate,
            int page,
            int size,
            String requestId
    ) {
        return listByStatus(userId, "SAVED", fromLocalDate, toLocalDate, page, size, requestId);
    }

    @Transactional(readOnly = true)
    public FoodLogListResponse listByStatus(
            Long userId,
            String statusRaw,
            LocalDate fromLocalDate,
            LocalDate toLocalDate,
            int page,
            int size,
            String requestId
    ) {
        FoodLogStatus status = parseStatusOrThrow(statusRaw);

        if (size <= 0) size = 20;
        if (size > 50) throw new IllegalArgumentException("PAGE_SIZE_TOO_LARGE");
        if (page < 0) page = 0;

        if (fromLocalDate == null || toLocalDate == null) throw new IllegalArgumentException("DATE_RANGE_REQUIRED");
        if (fromLocalDate.isAfter(toLocalDate)) throw new IllegalArgumentException("DATE_RANGE_INVALID");

        var pageable = PageRequest.of(page, size);
        var p = logRepo.findByUserIdAndStatusAndCapturedLocalDateRange(userId, status, fromLocalDate, toLocalDate, pageable);

        var items = p.getContent().stream().map(this::toItem).toList();

        return new FoodLogListResponse(
                items,
                new FoodLogListResponse.Page(p.getNumber(), p.getSize(), p.getTotalElements(), p.getTotalPages()),
                new FoodLogEnvelope.Trace(requestId)
        );
    }

    private static FoodLogStatus parseStatusOrThrow(String raw) {
        if (raw == null) throw new IllegalArgumentException("BAD_REQUEST");
        String v = raw.trim().toUpperCase(Locale.ROOT);
        try {
            return FoodLogStatus.valueOf(v);
        } catch (Exception e) {
            throw new IllegalArgumentException("BAD_REQUEST");
        }
    }

    private FoodLogListResponse.Item toItem(FoodLogEntity e) {
        JsonNode eff = e.getEffective();
        String foodName = null;
        Double kcal = null, protein = null, fat = null, carbs = null;

        if (eff != null && eff.isObject()) {
            foodName = textOrNull(eff.get("foodName"));
            JsonNode n = eff.get("nutrients");
            if (n != null && n.isObject()) {
                kcal = doubleOrNull(n.get("kcal"));
                protein = doubleOrNull(n.get("protein"));
                fat = doubleOrNull(n.get("fat"));
                carbs = doubleOrNull(n.get("carbs"));
            }
        }

        return new FoodLogListResponse.Item(
                e.getId(),
                e.getStatus().name(),
                e.getCapturedLocalDate() == null ? null : e.getCapturedLocalDate().toString(),
                e.getCapturedAtUtc() == null ? null : e.getCapturedAtUtc().toString(),
                new FoodLogListResponse.Nutrition(foodName, kcal, protein, fat, carbs)
        );
    }

    private static String textOrNull(JsonNode v) { return (v == null || v.isNull()) ? null : v.asText(); }
    private static Double doubleOrNull(JsonNode v) { return (v == null || v.isNull()) ? null : v.asDouble(); }
}
package com.calai.backend.foodlog.service;

import com.calai.backend.foodlog.dto.FoodLogEnvelope;
import com.calai.backend.foodlog.dto.FoodLogFieldKey;
import com.calai.backend.foodlog.dto.FoodLogOverrideRequest;
import com.calai.backend.foodlog.dto.FoodLogStatus;
import com.calai.backend.foodlog.entity.FoodLogEntity;
import com.calai.backend.foodlog.entity.FoodLogOverrideEntity;
import com.calai.backend.foodlog.repo.FoodLogOverrideRepository;
import com.calai.backend.foodlog.repo.FoodLogRepository;
import com.fasterxml.jackson.databind.JsonNode;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.Map;

@RequiredArgsConstructor
@Service
public class FoodLogOverrideService {

    private final FoodLogRepository logRepo;
    private final FoodLogOverrideRepository overrideRepo;
    private final FoodLogService foodLogService;

    @Transactional
    public FoodLogEnvelope applyOverride(Long userId, String foodLogId, FoodLogOverrideRequest req, String requestId) {
        if (req == null) throw new IllegalArgumentException("OVERRIDE_VALUE_INVALID");

        FoodLogFieldKey key = FoodLogFieldKey.parse(req.fieldKey());
        if (key == null) throw new IllegalArgumentException("FIELD_KEY_INVALID");

        FoodLogEntity log = logRepo.findByIdForUpdate(foodLogId);
        if (!userId.equals(log.getUserId())) throw new IllegalArgumentException("FOOD_LOG_NOT_FOUND");

        if (log.getStatus() == FoodLogStatus.DELETED) throw new IllegalArgumentException("FOOD_LOG_DELETED");
        if (log.getStatus() != FoodLogStatus.DRAFT) {
            // ✅ MVP：只允許 DRAFT 編輯
            throw new IllegalArgumentException("FOOD_LOG_NOT_EDITABLE");
        }

        validateNewValueOrThrow(key, req.newValue());

        JsonNode oldValue = extractOldValue(log.getEffective(), key);

        FoodLogOverrideEntity ov = FoodLogOverrideEntity.create(
                foodLogId,
                key.name(),
                oldValue,
                req.newValue(),
                "USER",
                req.reason(),
                Instant.now()
        );
        overrideRepo.save(ov);

        // ✅ patch effective
        log.applyEffectivePatch(key.name(), req.newValue());
        logRepo.save(log);

        return foodLogService.getOne(userId, foodLogId, requestId);
    }

    private static JsonNode extractOldValue(JsonNode effective, FoodLogFieldKey key) {
        if (effective == null || effective.isNull() || !effective.isObject()) return null;

        return switch (key) {
            case FOOD_NAME -> effective.get("foodName");
            case QUANTITY -> effective.get("quantity");
            case NUTRIENTS -> effective.get("nutrients");
            case HEALTH_SCORE -> effective.get("healthScore");
        };
    }

    private static void validateNewValueOrThrow(FoodLogFieldKey key, JsonNode v) {
        if (v == null || v.isNull()) throw new IllegalArgumentException("OVERRIDE_VALUE_INVALID");

        switch (key) {
            case FOOD_NAME -> {
                if (!v.isTextual()) throw new IllegalArgumentException("OVERRIDE_VALUE_INVALID");
                String s = v.asText().trim();
                if (s.isEmpty() || s.length() > 80) throw new IllegalArgumentException("OVERRIDE_VALUE_INVALID");
            }
            case HEALTH_SCORE -> {
                if (!v.isInt() && !v.isIntegralNumber()) throw new IllegalArgumentException("OVERRIDE_VALUE_INVALID");
                int n = v.asInt();
                if (n < 1 || n > 10) throw new IllegalArgumentException("OVERRIDE_VALUE_INVALID");
            }
            case QUANTITY -> {
                if (!v.isObject()) throw new IllegalArgumentException("OVERRIDE_VALUE_INVALID");
                JsonNode value = v.get("value");
                JsonNode unit = v.get("unit");
                if (value == null || !value.isNumber()) throw new IllegalArgumentException("OVERRIDE_VALUE_INVALID");
                if (value.asDouble() < 0d) throw new IllegalArgumentException("OVERRIDE_VALUE_INVALID");
                if (unit == null || !unit.isTextual() || unit.asText().trim().isEmpty()) {
                    throw new IllegalArgumentException("OVERRIDE_VALUE_INVALID");
                }
            }
            case NUTRIENTS -> {
                if (!v.isObject()) throw new IllegalArgumentException("OVERRIDE_VALUE_INVALID");
                // ✅ 允許 partial，但每個有提供的欄位都必須 >= 0
                for (Map.Entry<String, JsonNode> e : v.properties()) {
                    JsonNode nv = e.getValue();
                    if (nv == null || !nv.isNumber() || nv.asDouble() < 0d) {
                        throw new IllegalArgumentException("OVERRIDE_VALUE_INVALID");
                    }
                }
            }
        }
    }
}
package com.calai.backend.foodlog.service;

import com.calai.backend.foodlog.dto.FoodLogEnvelope;
import com.calai.backend.foodlog.dto.FoodLogStatus;
import com.calai.backend.foodlog.dto.TimeSource;
import com.calai.backend.foodlog.entity.FoodLogEntity;
import com.calai.backend.foodlog.entity.FoodLogTaskEntity;
import com.calai.backend.foodlog.image.ImageSniffer;
import com.calai.backend.foodlog.repo.FoodLogRepository;
import com.calai.backend.foodlog.repo.FoodLogTaskRepository;
import com.calai.backend.foodlog.service.limiter.UserInFlightLimiter;
import com.calai.backend.foodlog.service.limiter.UserRateLimiter;
import com.calai.backend.foodlog.storage.StorageService;
import com.calai.backend.foodlog.time.CapturedTimeResolver;
import com.calai.backend.foodlog.time.ExifTimeExtractor;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;
import com.calai.backend.foodlog.service.cleanup.StorageCleanup;
import java.io.InputStream;
import java.io.PushbackInputStream;
import java.time.*;
import java.util.List;
import java.util.Optional;

@RequiredArgsConstructor
@Service
public class FoodLogService {

    private static final long MAX_IMAGE_BYTES = 8L * 1024 * 1024; // 8MB（先保守）

    private final FoodLogRepository repo;
    private final FoodLogTaskRepository taskRepo;
    private final StorageService storage;
    private final ObjectMapper om; // 目前留著，之後 provider 會用到
    private final QuotaService quota;
    private final IdempotencyService idem;
    private final ImageBlobService blobService;
    private final UserInFlightLimiter inFlight;
    private final UserRateLimiter rateLimiter;

    // MVP：先 new（後續要 DI 也可以）
    private final CapturedTimeResolver timeResolver = new CapturedTimeResolver();

    public record OpenedImage(String objectKey, String contentType, long sizeBytes) {}

    // =========================
    // S4-05：ALBUM
    // =========================
    @Transactional
    public FoodLogEnvelope createAlbum(Long userId, String clientTz, MultipartFile file, String requestId) throws Exception {
        ZoneId tz = parseTzOrUtc(clientTz);
        Instant serverNow = Instant.now();
        validateUploadBasics(file);

        String existingLogId = idem.reserveOrGetExisting(userId, requestId, serverNow);
        if (existingLogId != null) return getOne(userId, existingLogId, requestId);

        rateLimiter.checkOrThrow(userId, serverNow);

        boolean acquired = false;
        String tempKey = null; // ✅ 讓所有 catch 都能刪到正確 key（含副檔名）

        try {
            inFlight.acquireOrThrow(userId);
            acquired = true;

            ImageSniffer.Detection det;
            StorageService.SaveResult saved;

            // 3) 上傳 → tempKey
            try (InputStream raw = file.getInputStream();
                 PushbackInputStream in = new PushbackInputStream(raw, 16)) {

                det = ImageSniffer.detect(in);
                if (det == null) throw new IllegalArgumentException("UNSUPPORTED_IMAGE_FORMAT");

                // ✅ detect 成功就先決定 tempKey（帶 ext）
                tempKey = "user-" + userId + "/blobs/tmp/" + requestId + "/upload" + det.ext();

                saved = storage.save(tempKey, in, det.contentType());

            } catch (Exception ex) {
                // ✅ 上傳失敗也嘗試刪 temp（即使不存在也不會炸）
                StorageCleanup.safeDeleteQuietly(storage, tempKey);
                if (tempKey == null) StorageCleanup.safeDeleteTempUploadFallback(storage, userId, requestId);

                idem.failAndReleaseIfNeeded(userId, requestId, "UPLOAD_FAILED", safeMsg(ex), true);
                throw ex;
            }

            try {
                // 4) 去重命中（不扣 quota）
                var hit = repo.findFirstByUserIdAndImageSha256AndStatusInOrderByCreatedAtUtcDesc(
                        userId,
                        saved.sha256(),
                        List.of(FoodLogStatus.DRAFT, FoodLogStatus.SAVED)
                );

                // 5) 建 log
                LocalDate todayLocal = ZonedDateTime.ofInstant(serverNow, tz).toLocalDate();

                FoodLogEntity e = new FoodLogEntity();
                e.setUserId(userId);
                e.setMethod("ALBUM");
                e.setDegradeLevel("DG-0");
                e.setCapturedAtUtc(serverNow);
                e.setCapturedTz(tz.getId());
                e.setCapturedLocalDate(todayLocal);
                e.setServerReceivedAtUtc(serverNow);
                e.setTimeSource(TimeSource.SERVER_RECEIVED);
                e.setTimeSuspect(false);

                if (hit.isPresent() && hit.get().getEffective() != null) {
                    e.setProvider(hit.get().getProvider());
                    e.setEffective(hit.get().getEffective());
                    e.setStatus(FoodLogStatus.DRAFT);
                } else {
                    quota.consumeAiOrThrow(userId, tz, serverNow);
                    e.setProvider("STUB");
                    e.setEffective(null);
                    e.setStatus(FoodLogStatus.PENDING);
                }

                repo.save(e);
                idem.attach(userId, requestId, e.getId(), serverNow);

                // 6) temp -> blobKey + refCount
                var retained = blobService.retainFromTemp(
                        userId,
                        tempKey,
                        saved.sha256(),
                        det.ext(),
                        saved.contentType(),
                        saved.sizeBytes()
                );

                e.setImageObjectKey(retained.objectKey());
                e.setImageSha256(retained.sha256());
                e.setImageContentType(saved.contentType());
                e.setImageSizeBytes(saved.sizeBytes());
                repo.save(e);

                if (e.getStatus() == FoodLogStatus.DRAFT) {
                    return toEnvelope(e, null, requestId);
                }

                FoodLogTaskEntity t = new FoodLogTaskEntity();
                t.setFoodLogId(e.getId());
                t.setTaskStatus(FoodLogTaskEntity.TaskStatus.QUEUED);
                t.setPollAfterSec(2);
                t.setNextRetryAtUtc(null);
                taskRepo.save(t);

                return toEnvelope(e, t, requestId);

            } catch (Exception ex) {
                // ✅ 以前你這裡 hard-code ".../upload" 現在改成刪 tempKey
                StorageCleanup.safeDeleteQuietly(storage, tempKey);

                idem.failAndReleaseIfNeeded(userId, requestId, "CREATE_ALBUM_FAILED", safeMsg(ex), true);
                throw ex;
            }

        } finally {
            if (acquired) inFlight.release(userId);
        }
    }

    // =========================
    // S4-08：PHOTO
    // =========================
    @Transactional
    public FoodLogEnvelope createPhoto(Long userId,
                                       String clientTz,
                                       String deviceCapturedAtUtc,
                                       MultipartFile file,
                                       String requestId) throws Exception {

        ZoneId tz = parseTzOrUtc(clientTz);
        Instant serverNow = Instant.now();
        validateUploadBasics(file);

        String existingLogId = idem.reserveOrGetExisting(userId, requestId, serverNow);
        if (existingLogId != null) return getOne(userId, existingLogId, requestId);

        rateLimiter.checkOrThrow(userId, serverNow);

        boolean acquired = false;
        String tempKey = null; // ✅ 讓所有 catch 都能刪到正確 key（含副檔名）

        try {
            inFlight.acquireOrThrow(userId);
            acquired = true;

            ImageSniffer.Detection det;
            StorageService.SaveResult saved;

            // 1) 上傳 → tempKey
            try (InputStream raw = file.getInputStream();
                 PushbackInputStream in = new PushbackInputStream(raw, 16)) {

                det = ImageSniffer.detect(in);
                if (det == null) throw new IllegalArgumentException("UNSUPPORTED_IMAGE_FORMAT");

                // ✅ detect 成功就先決定 tempKey（帶 ext）
                tempKey = "user-" + userId + "/blobs/tmp/" + requestId + "/upload" + det.ext();

                saved = storage.save(tempKey, in, det.contentType());

            } catch (Exception ex) {
                StorageCleanup.safeDeleteQuietly(storage, tempKey);
                if (tempKey == null) StorageCleanup.safeDeleteTempUploadFallback(storage, userId, requestId);
                idem.failAndReleaseIfNeeded(userId, requestId, "UPLOAD_FAILED", safeMsg(ex), true);
                throw ex;
            }

            try {
                // 2) EXIF（從 tempKey 再 open 一次讀）
                Optional<Instant> exifUtc = ExifTimeExtractor.tryReadCapturedAtUtc(storage, tempKey, tz);

                // 3) deviceCapturedAtUtc（App 可傳）
                Instant deviceUtc = parseInstantOrNull(deviceCapturedAtUtc);

                // 4) resolve capturedAtUtc（EXIF → DEVICE → SERVER）
                CapturedTimeResolver.Result r = timeResolver.resolve(exifUtc.orElse(null), deviceUtc, serverNow);

                // 5) 去重命中（不扣 quota）
                var hit = repo.findFirstByUserIdAndImageSha256AndStatusInOrderByCreatedAtUtcDesc(
                        userId,
                        saved.sha256(),
                        List.of(FoodLogStatus.DRAFT, FoodLogStatus.SAVED)
                );

                // 6) 建 log（capturedLocalDate 用 resolved capturedAtUtc + client tz）
                LocalDate localDate = ZonedDateTime.ofInstant(r.capturedAtUtc(), tz).toLocalDate();

                FoodLogEntity e = new FoodLogEntity();
                e.setUserId(userId);
                e.setMethod("PHOTO");
                e.setDegradeLevel("DG-0");

                e.setCapturedAtUtc(r.capturedAtUtc());
                e.setCapturedTz(tz.getId());
                e.setCapturedLocalDate(localDate);
                e.setServerReceivedAtUtc(serverNow);

                e.setTimeSource(TimeSource.valueOf(r.source().name()));
                e.setTimeSuspect(r.suspect());

                if (hit.isPresent() && hit.get().getEffective() != null) {
                    e.setProvider(hit.get().getProvider());
                    e.setEffective(hit.get().getEffective());
                    e.setStatus(FoodLogStatus.DRAFT);
                } else {
                    quota.consumeAiOrThrow(userId, tz, serverNow);
                    e.setProvider("STUB");
                    e.setEffective(null);
                    e.setStatus(FoodLogStatus.PENDING);
                }

                repo.save(e);
                idem.attach(userId, requestId, e.getId(), serverNow);

                // 7) temp -> blob + refCount
                var retained = blobService.retainFromTemp(
                        userId,
                        tempKey,
                        saved.sha256(),
                        det.ext(),
                        saved.contentType(),
                        saved.sizeBytes()
                );

                e.setImageObjectKey(retained.objectKey());
                e.setImageSha256(retained.sha256());
                e.setImageContentType(saved.contentType());
                e.setImageSizeBytes(saved.sizeBytes());
                repo.save(e);

                // 8) 命中：不建 task
                if (e.getStatus() == FoodLogStatus.DRAFT) {
                    return toEnvelope(e, null, requestId);
                }

                // 9) 未命中：建 task
                FoodLogTaskEntity t = new FoodLogTaskEntity();
                t.setFoodLogId(e.getId());
                t.setTaskStatus(FoodLogTaskEntity.TaskStatus.QUEUED);
                t.setPollAfterSec(2);
                t.setNextRetryAtUtc(null);
                taskRepo.save(t);

                return toEnvelope(e, t, requestId);

            } catch (Exception ex) {
                // ✅ 以前你這裡 hard-code ".../upload" 現在改成刪 tempKey
                StorageCleanup.safeDeleteQuietly(storage, tempKey);
                idem.failAndReleaseIfNeeded(userId, requestId, "CREATE_PHOTO_FAILED", safeMsg(ex), true);
                throw ex;
            }

        } finally {
            if (acquired) inFlight.release(userId);
        }
    }

    @Transactional(readOnly = true)
    public FoodLogEnvelope getOne(Long userId, String id, String requestId) {
        FoodLogEntity e = repo.findByIdAndUserId(id, userId)
                .orElseThrow(() -> new IllegalArgumentException("FOOD_LOG_NOT_FOUND"));

        FoodLogTaskEntity t = null;
        if (e.getStatus() == FoodLogStatus.PENDING || e.getStatus() == FoodLogStatus.FAILED) {
            t = taskRepo.findByFoodLogId(e.getId()).orElse(null);
        }

        return toEnvelope(e, t, requestId);
    }

    private FoodLogEnvelope toEnvelope(FoodLogEntity e, FoodLogTaskEntity t, String requestId) {
        JsonNode eff = e.getEffective();
        FoodLogEnvelope.NutritionResult nr = null;

        if (eff != null && !eff.isNull()) {
            JsonNode n = eff.get("nutrients");
            JsonNode q = eff.get("quantity");
            nr = new FoodLogEnvelope.NutritionResult(
                    textOrNull(eff, "foodName"),
                    q == null ? null : new FoodLogEnvelope.Quantity(doubleOrNull(q, "value"), textOrNull(q, "unit")),
                    n == null ? null : new FoodLogEnvelope.Nutrients(
                            doubleOrNull(n, "kcal"),
                            doubleOrNull(n, "protein"),
                            doubleOrNull(n, "fat"),
                            doubleOrNull(n, "carbs"),
                            doubleOrNull(n, "fiber"),
                            doubleOrNull(n, "sugar"),
                            doubleOrNull(n, "sodium")
                    ),
                    intOrNull(eff, "healthScore"),
                    doubleOrNull(eff, "confidence"),
                    new FoodLogEnvelope.Source(e.getMethod(), e.getProvider())
            );
        }

        FoodLogEnvelope.Task task = null;
        if (t != null && (e.getStatus() == FoodLogStatus.PENDING || e.getStatus() == FoodLogStatus.FAILED)) {
            task = new FoodLogEnvelope.Task(t.getId(), t.getPollAfterSec());
        }

        FoodLogEnvelope.ApiError err = null;
        if (e.getStatus() == FoodLogStatus.FAILED) {
            Integer retryAfter = null;
            if (t != null && t.getNextRetryAtUtc() != null) {
                long sec = Duration.between(Instant.now(), t.getNextRetryAtUtc()).getSeconds();
                if (sec < 0) sec = 0;
                if (sec > Integer.MAX_VALUE) sec = Integer.MAX_VALUE;
                retryAfter = (int) sec;
            }
            err = new FoodLogEnvelope.ApiError(
                    e.getLastErrorCode(),
                    "RETRY_LATER",
                    retryAfter
            );
        }

        return new FoodLogEnvelope(
                e.getId(),
                e.getStatus().name(),
                e.getDegradeLevel(),
                nr,
                task,
                err,
                new FoodLogEnvelope.Trace(requestId)
        );
    }

    @Transactional(readOnly = true)
    public OpenedImage openImage(Long userId, String foodLogId) {
        var log = repo.findByIdAndUserId(foodLogId, userId)
                .orElseThrow(() -> new IllegalArgumentException("FOOD_LOG_NOT_FOUND"));

        if (log.getStatus() == FoodLogStatus.DELETED) {
            throw new IllegalArgumentException("FOOD_LOG_DELETED");
        }
        if (log.getImageObjectKey() == null || log.getImageObjectKey().isBlank()) {
            throw new IllegalStateException("IMAGE_OBJECT_KEY_MISSING");
        }

        long size = log.getImageSizeBytes() == null ? -1L : log.getImageSizeBytes();
        return new OpenedImage(log.getImageObjectKey(), log.getImageContentType(), size);
    }

    public InputStream openImageStream(String objectKey) throws Exception {
        return storage.open(objectKey).inputStream();
    }

    @Transactional
    public FoodLogEnvelope retry(Long userId, String foodLogId, String requestId) {
        Instant now = Instant.now();

        // ✅ retry 也要擋一下，不然狂點 retry 一樣會打爆
        rateLimiter.checkOrThrow(userId, now);

        FoodLogEntity log = repo.findByIdForUpdate(foodLogId);
        if (!userId.equals(log.getUserId())) throw new IllegalArgumentException("FOOD_LOG_NOT_FOUND");

        if (log.getStatus() == FoodLogStatus.DELETED) throw new IllegalArgumentException("FOOD_LOG_DELETED");
        if (log.getStatus() == FoodLogStatus.DRAFT || log.getStatus() == FoodLogStatus.SAVED) {
            throw new IllegalArgumentException("FOOD_LOG_NOT_RETRYABLE");
        }
        if (log.getStatus() != FoodLogStatus.FAILED) {
            throw new IllegalArgumentException("FOOD_LOG_NOT_RETRYABLE");
        }

        ZoneId tz = ZoneId.of(log.getCapturedTz());
        quota.consumeAiOrThrow(userId, tz, now);

        Optional<FoodLogTaskEntity> opt = taskRepo.findByFoodLogIdForUpdate(foodLogId);
        FoodLogTaskEntity task = opt.orElseGet(() -> {
            FoodLogTaskEntity t = new FoodLogTaskEntity();
            t.setFoodLogId(foodLogId);
            t.setTaskStatus(FoodLogTaskEntity.TaskStatus.QUEUED);
            t.setPollAfterSec(2);
            t.setAttempts(0);
            return t;
        });

        task.setTaskStatus(FoodLogTaskEntity.TaskStatus.QUEUED);
        task.setNextRetryAtUtc(null);
        task.setPollAfterSec(2);
        task.setAttempts(0);
        task.setLastErrorCode(null);
        task.setLastErrorMessage(null);
        taskRepo.save(task);

        log.setStatus(FoodLogStatus.PENDING);
        log.setLastErrorCode(null);
        log.setLastErrorMessage(null);
        repo.save(log);

        return getOne(userId, foodLogId, requestId);
    }

    // =========================
    // helpers
    // =========================

    private static Instant parseInstantOrNull(String raw) {
        try {
            if (raw == null || raw.isBlank()) return null;
            return Instant.parse(raw.trim());
        } catch (Exception ignored) {
            return null;
        }
    }

    private static String safeMsg(Throwable t) {
        String m = t.getMessage();
        return (m == null || m.isBlank()) ? t.getClass().getSimpleName() : m;
    }

    private static void validateUploadBasics(MultipartFile file) {
        if (file == null || file.isEmpty()) throw new IllegalArgumentException("FILE_REQUIRED");
        if (file.getSize() > MAX_IMAGE_BYTES) throw new IllegalArgumentException("FILE_TOO_LARGE");
    }

    private static ZoneId parseTzOrUtc(String tz) {
        try { return (tz == null || tz.isBlank()) ? ZoneOffset.UTC : ZoneId.of(tz); }
        catch (Exception ignored) { return ZoneOffset.UTC; }
    }

    private static String textOrNull(JsonNode node, String field) {
        JsonNode v = node.get(field);
        return (v == null || v.isNull()) ? null : v.asText();
    }

    private static Integer intOrNull(JsonNode node, String field) {
        JsonNode v = node.get(field);
        return (v == null || v.isNull()) ? null : v.asInt();
    }

    private static Double doubleOrNull(JsonNode node, String field) {
        JsonNode v = node.get(field);
        return (v == null || v.isNull()) ? null : v.asDouble();
    }
}
package com.calai.backend.foodlog.service;

import com.calai.backend.foodlog.repo.FoodLogRequestRepository;
import com.calai.backend.foodlog.web.RequestInProgressException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;

@RequiredArgsConstructor
@Service
public class IdempotencyService {

    private final FoodLogRequestRepository repo;

    /**
     * @return 已存在的 foodLogId；若回 null 代表你取得了 RESERVED，可以繼續做真正流程
     */
    @Transactional
    public String reserveOrGetExisting(Long userId, String requestId, Instant now) {
        if (requestId == null || requestId.isBlank()) return null;

        String existing = repo.findFoodLogId(userId, requestId);
        if (existing != null && !existing.isBlank()) return existing;

        // ✅ 如果上一輪 FAILED 且未 attach，直接釋放，讓同 requestId 可重試
        String status = repo.findStatus(userId, requestId);
        if ("FAILED".equalsIgnoreCase(status)) {
            repo.deleteFailedIfNotAttached(userId, requestId);
        }

        int inserted = repo.reserve(userId, requestId, now);
        if (inserted == 1) return null;

        // 已有人 reserve 了，但還沒 attach foodLogId
        status = repo.findStatus(userId, requestId);
        if ("RESERVED".equalsIgnoreCase(status)) {
            throw new RequestInProgressException("REQUEST_IN_PROGRESS", 1);
        }

        existing = repo.findFoodLogId(userId, requestId);
        if (existing != null && !existing.isBlank()) return existing;

        // 其他狀態一律視為仍在處理（保守）
        throw new RequestInProgressException("REQUEST_IN_PROGRESS", 1);
    }

    @Transactional
    public void attach(Long userId, String requestId, String foodLogId, Instant now) {
        if (requestId == null || requestId.isBlank()) return;
        repo.attach(userId, requestId, foodLogId, now);
    }

    @Transactional
    public void failAndReleaseIfNeeded(Long userId, String requestId, String code, String msg, boolean releaseIfNotAttached) {
        if (requestId == null || requestId.isBlank()) return;
        repo.markFailed(userId, requestId, code, msg, Instant.now());
        if (releaseIfNotAttached) {
            repo.releaseIfNotAttached(userId, requestId); // ✅ 你原本就有
        }
    }
}
package com.calai.backend.foodlog.service;

import com.calai.backend.foodlog.entity.ImageBlobEntity;
import com.calai.backend.foodlog.repo.ImageBlobRepository;
import com.calai.backend.foodlog.storage.StorageService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.nio.file.FileAlreadyExistsException;
import java.time.Instant;

@RequiredArgsConstructor
@Service
public class ImageBlobService {

    private final ImageBlobRepository repo;
    private final StorageService storage;

    public record RetainResult(String objectKey, String sha256) {}

    /**
     * ✅ 將 temp 檔案「提升」成內容定址 blob：
     * - 若首次：insertFirst=1 → move(temp -> blobKey)
     * - 若已存在：retain ref_count → delete(temp)
     */
    @Transactional
    public RetainResult retainFromTemp(Long userId,
                                       String tempKey,
                                       String sha256,
                                       String ext,
                                       String contentType,
                                       long sizeBytes) throws Exception {

        Instant now = Instant.now();
        String blobKey = blobKey(userId, sha256, ext);

        int inserted = repo.insertFirst(userId, sha256, blobKey, contentType, sizeBytes, ext, now);
        if (inserted == 1) {
            // 我是第一個建立 blob 的人：把 temp 搬到 blobKey
            try {
                // 若極端併發：blobKey 可能已被別人搬好（ATOMIC_MOVE 會拋例外）
                if (storage.exists(blobKey)) {
                    storage.delete(tempKey);
                } else {
                    storage.move(tempKey, blobKey);
                }
            } catch (FileAlreadyExistsException e) {
                // 另一個請求先 move 成功了
                storage.delete(tempKey);
            } catch (Exception ex) {
                // 補償：blob row 已插入但檔案沒到位 → 刪 temp + 將 refCount 歸零並刪 row（簡化）
                try { storage.delete(tempKey); } catch (Exception ignored) {}
                repo.release(userId, sha256, Instant.now());
                repo.deleteIfZero(userId, sha256);
                throw ex;
            }
            return new RetainResult(blobKey, sha256);
        }

        // 已存在：ref_count + 1，並刪 temp
        repo.retain(userId, sha256, now);
        storage.delete(tempKey);

        return new RetainResult(blobKey, sha256);
    }

    /** 刪除引用：ref_count--；若變 0 才刪檔與 row */
    @Transactional
    public void release(Long userId, String sha256, String ext) throws Exception {
        Instant now = Instant.now();
        repo.release(userId, sha256, now);

        Integer rc = repo.getRefCount(userId, sha256);
        if (rc != null && rc <= 0) {
            String key = blobKey(userId, sha256, ext);
            try { storage.delete(key); } catch (Exception ignored) {}
            repo.deleteIfZero(userId, sha256);
        }
    }

    private static String blobKey(Long userId, String sha256, String ext) {
        return "user-" + userId + "/blobs/sha256/" + sha256 + ext;
    }

    public String findExtOrNull(Long userId, String sha256) {
        return repo.findByUserIdAndSha256(userId, sha256)
                .map(ImageBlobEntity::getExt)
                .orElse(null);
    }

}
package com.calai.backend.foodlog.service;

import com.calai.backend.foodlog.crypto.AesGcmCrypto;
import com.calai.backend.foodlog.entity.LogMealAccountEntity;
import com.calai.backend.foodlog.repo.LogMealAccountRepository;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@ConditionalOnProperty(name = "app.foodlog.provider", havingValue = "LOGMEAL")
public class LogMealTokenService {

    private final LogMealAccountRepository repo;
    private final AesGcmCrypto crypto;

    public LogMealTokenService(LogMealAccountRepository repo, AesGcmCrypto crypto) {
        this.repo = repo;
        this.crypto = crypto;
    }

    @Transactional(readOnly = true)
    public String requireApiUserToken(Long userId) {
        var e = repo.findByUserId(userId)
                .orElseThrow(() -> new IllegalStateException("LOGMEAL_TOKEN_MISSING"));
        if (!"ACTIVE".equalsIgnoreCase(e.getStatus())) {
            throw new IllegalStateException("LOGMEAL_TOKEN_DISABLED");
        }
        return crypto.decryptFromBase64(e.getApiUserTokenEnc());
    }

    @Transactional
    public void upsertToken(Long userId, String plainToken) {
        var e = repo.findByUserId(userId).orElseGet(LogMealAccountEntity::new);
        e.setUserId(userId);
        e.setApiUserTokenEnc(crypto.encryptToBase64(plainToken));
        e.setStatus("ACTIVE");
        repo.save(e);
    }
}
package com.calai.backend.foodlog.service;


import com.calai.backend.foodlog.quota.QuotaDayKey;
import com.calai.backend.foodlog.repo.UsageCounterRepository;
import com.calai.backend.foodlog.web.QuotaExceededException;
import com.calai.backend.foodlog.web.SubscriptionRequiredException;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.*;

@RequiredArgsConstructor
@Service
public class QuotaService {

    private final UsageCounterRepository repo;
    private final EntitlementService entitlement;

    @Value("${app.quota.daily.trial:30}")
    private int trialLimit;

    @Value("${app.quota.daily.monthly:200}")
    private int monthlyLimit;

    @Value("${app.quota.daily.yearly:400}")
    private int yearlyLimit;

    /**
     * ✅ 原子扣點：
     * - row 不存在：INSERT used_count=1（若超過 limit，當場擋）
     * - row 存在：UPDATE ... WHERE used_count < limit
     */
    @Transactional
    public LocalDate consumeAiOrThrow(Long userId, ZoneId userTz, Instant serverNowUtc) {
        EntitlementService.Tier tier = entitlement.resolveTier(userId, serverNowUtc);
        int limit = limitOf(tier);

        if (limit <= 0) {
            throw new SubscriptionRequiredException("SUBSCRIPTION_REQUIRED", "GO_SUBSCRIBE");
        }

        LocalDate dayKey = QuotaDayKey.todayLocalDate(serverNowUtc, userTz);

        int inserted = repo.insertFirstUse(userId, dayKey, serverNowUtc);
        if (inserted == 1) {
            // 第一次使用直接 used_count=1；若 limit=0 才會不合法（上面已擋）
            if (1 > limit) {
                int retryAfter = secondsUntilNextLocalDay(serverNowUtc, userTz);
                throw new QuotaExceededException("QUOTA_EXCEEDED", retryAfter, "WAIT_TOMORROW");
            }
            return dayKey;
        }

        int updated = repo.incrementIfBelowLimit(userId, dayKey, limit, serverNowUtc);
        if (updated == 1) return dayKey;

        int retryAfter = secondsUntilNextLocalDay(serverNowUtc, userTz);
        throw new QuotaExceededException("QUOTA_EXCEEDED", retryAfter, "WAIT_TOMORROW");
    }

    private int limitOf(EntitlementService.Tier tier) {
        return switch (tier) {
            case TRIAL -> trialLimit;
            case MONTHLY -> monthlyLimit;
            case YEARLY -> yearlyLimit;
            case NONE -> 0;
        };
    }

    private static int secondsUntilNextLocalDay(Instant nowUtc, ZoneId tz) {
        ZonedDateTime now = ZonedDateTime.ofInstant(nowUtc, tz);
        ZonedDateTime next = now.toLocalDate().plusDays(1).atStartOfDay(tz);
        long sec = Duration.between(now, next).getSeconds();
        if (sec < 0) sec = 0;
        if (sec > Integer.MAX_VALUE) sec = Integer.MAX_VALUE;
        return (int) sec;
    }
}
package com.calai.backend.foodlog.storage;

import lombok.Getter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.io.*;
import java.nio.file.*;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.util.HexFormat;

@Getter
@Service
public class LocalDiskStorageService implements StorageService {

    private final Path baseDir;

    public LocalDiskStorageService(@Value("${app.storage.local.base-dir:./data}") String baseDir) {
        this.baseDir = Paths.get(baseDir).toAbsolutePath().normalize();
    }

    @Override
    public SaveResult save(String objectKey, InputStream in, String contentType) throws Exception {
        Path path = resolve(objectKey);
        Files.createDirectories(path.getParent());

        MessageDigest md = MessageDigest.getInstance("SHA-256");

        long size = 0;
        try (DigestInputStream din = new DigestInputStream(in, md);
             OutputStream out = Files.newOutputStream(path, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {

            byte[] buf = new byte[8192];
            int n;
            while ((n = din.read(buf)) >= 0) {
                out.write(buf, 0, n);
                size += n;
            }
        }

        String sha256 = HexFormat.of().formatHex(md.digest());
        return new SaveResult(objectKey, sha256, size, contentType);
    }

    @Override
    public OpenResult open(String objectKey) throws Exception {
        Path path = resolve(objectKey);
        if (!Files.exists(path)) throw new FileNotFoundException("OBJECT_NOT_FOUND: " + objectKey);

        String ct = Files.probeContentType(path);
        long size = Files.size(path);
        InputStream in = Files.newInputStream(path, StandardOpenOption.READ);
        return new OpenResult(in, size, ct);
    }

    @Override
    public void delete(String objectKey) throws Exception {
        Path path = resolve(objectKey);
        Files.deleteIfExists(path);
    }

    @Override
    public boolean exists(String objectKey) throws Exception {
        Path path = resolve(objectKey);
        return Files.exists(path);
    }

    @Override
    public void move(String fromObjectKey, String toObjectKey) throws Exception {
        Path from = resolve(fromObjectKey);
        Path to = resolve(toObjectKey);
        Files.createDirectories(to.getParent());

        try {
            Files.move(from, to, StandardCopyOption.ATOMIC_MOVE);
        } catch (AtomicMoveNotSupportedException e) {
            // fallback：非原子 move（本機 dev OK）
            Files.move(from, to);
        }
    }

    private Path resolve(String objectKey) {
        Path p = baseDir.resolve(objectKey).normalize();
        if (!p.startsWith(baseDir)) throw new SecurityException("Invalid objectKey");
        return p;
    }

}
package com.calai.backend.foodlog.storage;

import java.io.InputStream;

public interface StorageService {

    SaveResult save(String objectKey, InputStream in, String contentType) throws Exception;

    OpenResult open(String objectKey) throws Exception;

    void delete(String objectKey) throws Exception;

    /** ✅ Step 3.11：內容定址需要 */
    boolean exists(String objectKey) throws Exception;

    /** ✅ Step 3.11：temp -> blobKey 的原子搬移（LocalDisk 可用 move） */
    void move(String fromObjectKey, String toObjectKey) throws Exception;

    record SaveResult(String objectKey, String sha256, long sizeBytes, String contentType) {}

    record OpenResult(InputStream inputStream, long sizeBytes, String contentType) {}
}
package com.calai.backend.foodlog.task.config;

import org.springframework.boot.context.properties.ConfigurationProperties;

import java.time.Duration;

/**
 * application.yml:
 * app.storage.local.tmp-cleaner.*
 */
@ConfigurationProperties(prefix = "app.storage.local.tmp-cleaner")
public class LocalTempBlobCleanerProperties {

    /** 一鍵開關（prod 想關就關） */
    private boolean enabled = true;

    /** 保留多久（超過就刪） */
    private Duration keep = Duration.ofHours(6);

    /** 掃描最大深度（避免深層目錄拖慢） */
    private int maxDepth = 8;

    /** 固定延遲與初始延遲（@Scheduled 會用到字串 placeholder 讀這兩個 key） */
    private Duration fixedDelay = Duration.ofMinutes(10);
    private Duration initialDelay = Duration.ofMinutes(1);

    /** 是否刪空資料夾 */
    private boolean deleteEmptyDirs = true;

    /**
     * tmp 子路徑（相對於 base-dir）
     * 例：base=./data，tmpSubdir=blobs/tmp => ./data/blobs/tmp
     */
    private String tmpSubdir = "blobs/tmp";

    // ===== getters/setters =====
    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }

    public Duration getKeep() { return keep; }
    public void setKeep(Duration keep) { this.keep = keep; }

    public int getMaxDepth() { return maxDepth; }
    public void setMaxDepth(int maxDepth) { this.maxDepth = maxDepth; }

    public Duration getFixedDelay() { return fixedDelay; }
    public void setFixedDelay(Duration fixedDelay) { this.fixedDelay = fixedDelay; }

    public Duration getInitialDelay() { return initialDelay; }
    public void setInitialDelay(Duration initialDelay) { this.initialDelay = initialDelay; }

    public boolean isDeleteEmptyDirs() { return deleteEmptyDirs; }
    public void setDeleteEmptyDirs(boolean deleteEmptyDirs) { this.deleteEmptyDirs = deleteEmptyDirs; }

    public String getTmpSubdir() { return tmpSubdir; }
    public void setTmpSubdir(String tmpSubdir) { this.tmpSubdir = tmpSubdir; }
}
package com.calai.backend.foodlog.task.config;

import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableConfigurationProperties(LocalTempBlobCleanerProperties.class)
public class PropertiesConfig {
}
package com.calai.backend.foodlog.task;

import com.calai.backend.foodlog.dto.FoodLogStatus;
import com.calai.backend.foodlog.entity.DeletionJobEntity;
import com.calai.backend.foodlog.repo.DeletionJobRepository;
import com.calai.backend.foodlog.repo.FoodLogRepository;
import com.calai.backend.foodlog.service.ImageBlobService;
import com.calai.backend.foodlog.storage.StorageService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.List;

@Slf4j
@RequiredArgsConstructor
@Component
public class DeletionJobWorker {

    private static final int BATCH_SIZE = 20;

    private final DeletionJobRepository repo;
    private final ImageBlobService blobService;

    // ✅ fallback 需要的依賴
    private final FoodLogRepository foodLogRepo;
    private final StorageService storage;

    @Scheduled(fixedDelay = 3000)
    @Transactional
    public void runOnce() {
        Instant now = Instant.now();
        List<DeletionJobEntity> jobs = repo.claimRunnableForUpdate(now, BATCH_SIZE);

        for (DeletionJobEntity job : jobs) {
            try {
                job.markRunning(now);
                repo.save(job);

                // ✅ sha/ext 缺失：走 fallback（有 objectKey 才能做）
                if (isBlank(job.getSha256()) || isBlank(job.getExt())) {
                    handleFallbackCleanup(now, job, "MISSING_SHA_OR_EXT");
                    continue;
                }

                // ✅ 正常路徑：ref_count 歸零才刪檔（你 Step3.11）
                try {
                    blobService.release(job.getUserId(), job.getSha256(), job.getExt());
                    job.markSucceeded(now);
                    repo.save(job);
                } catch (Exception e) {
                    // ✅ 如果是 blob row missing：重試通常沒意義 → 改走 fallback
                    if (isBlobRowMissing(e)) {
                        handleFallbackCleanup(now, job, "BLOB_ROW_MISSING");
                        continue;
                    }
                    throw e;
                }

            } catch (Exception e) {
                log.warn("deletion job failed: id={}", job.getId(), e);
                int retryAfter = nextDelaySec(job.getAttempts());
                job.markFailed(now, safeMsg(e), retryAfter);
                repo.save(job);
            }
        }
    }

    /**
     * ✅ 安全閘 fallback：
     * 1) 有 image_object_key 才能清
     * 2) refs==0 才允許 move/delete
     * 3) refs>0：禁止刪 → CANCELLED + 留證據
     */
    private void handleFallbackCleanup(Instant now, DeletionJobEntity job, String reason) {
        String objectKey = job.getImageObjectKey();
        if (isBlank(objectKey)) {
            job.markCancelled(now, reason + ":MISSING_OBJECT_KEY");
            repo.save(job);
            return;
        }

        long refs = foodLogRepo.countLiveRefsByObjectKey(job.getUserId(), objectKey, FoodLogStatus.DELETED);
        if (refs > 0) {
            job.markCancelled(now, reason + ":REFERENCED refs=" + refs);
            repo.save(job);
            log.warn("fallback cleanup skipped (referenced). jobId={}, objectKey={}, refs={}",
                    job.getId(), objectKey, refs);
            return;
        }

        // ✅ refs==0 → 可以清。更保守：先 move 到 trash（可再加 TTL GC）
        try {
            if (storage.exists(objectKey)) {
                String trashKey = "user-" + job.getUserId()
                                  + "/blobs/trash/deletion-job-" + job.getId()
                                  + "/" + sanitizeFileName(objectKey);

                try {
                    storage.move(objectKey, trashKey);
                } catch (Exception moveEx) {
                    // move 不支援/失敗 → 降級 delete
                    storage.delete(objectKey);
                }
            }
            job.markSucceeded(now);
            repo.save(job);

        } catch (Exception ex) {
            // fallback 也失敗：回到 FAILED 可重試（或你也可以選擇 CANCELLED）
            job.markFailed(now, reason + ":FALLBACK_FAILED:" + safeMsg(ex), 60);
            repo.save(job);
        }
    }

    private static boolean isBlobRowMissing(Exception e) {
        // ✅ 依你的 blobService.release 實作調整：建議改成自訂例外型別更乾淨
        String m = e.getMessage();
        if (m == null) return false;
        return m.contains("BLOB_ROW_NOT_FOUND")
               || m.contains("IMAGE_BLOB_NOT_FOUND")
               || m.contains("blob row missing");
    }

    private static String sanitizeFileName(String objectKey) {
        // 只為了產生 trash key，不要讓 / 破壞路徑
        return objectKey.replace("/", "_");
    }

    private static boolean isBlank(String s) {
        return s == null || s.isBlank();
    }

    private static int nextDelaySec(int attempts) {
        if (attempts <= 1) return 2;
        if (attempts == 2) return 5;
        if (attempts == 3) return 15;
        if (attempts == 4) return 30;
        return 60;
    }

    private static String safeMsg(Throwable t) {
        String m = t.getMessage();
        return (m == null || m.isBlank()) ? t.getClass().getSimpleName() : m;
    }
}


package com.calai.backend.foodlog.task;

import com.calai.backend.foodlog.repo.FoodLogTaskRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.Duration;
import java.time.Instant;

@Slf4j
@RequiredArgsConstructor
@Component
public class FoodLogTaskReaper {

    private static final Duration RUNNING_TIMEOUT = Duration.ofMinutes(2);

    private final FoodLogTaskRepository taskRepo;

    @Scheduled(fixedDelay = 30_000)
    @Transactional
    public void reap() {
        Instant now = Instant.now();
        Instant staleBefore = now.minus(RUNNING_TIMEOUT);

        int n = taskRepo.resetStaleRunningAndMarkLogsFailed(
                staleBefore,
                now,
                "WORKER_STALE_RUNNING",
                "RUNNING timeout, reset to FAILED"
        );

        if (n > 0) log.warn("reaped stale RUNNING tasks+logs: count={}", n);
    }
}
package com.calai.backend.foodlog.task;

import com.calai.backend.foodlog.dto.FoodLogStatus;
import com.calai.backend.foodlog.entity.FoodLogTaskEntity;
import com.calai.backend.foodlog.repo.FoodLogRepository;
import com.calai.backend.foodlog.repo.FoodLogTaskRepository;
import com.calai.backend.foodlog.storage.StorageService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.List;

@Slf4j
@RequiredArgsConstructor
@Component
public class FoodLogTaskWorker {

    private static final int BATCH_SIZE = 10;

    private final FoodLogTaskRepository taskRepo;
    private final FoodLogRepository logRepo;
    private final ProviderClient providerClient;
    private final StorageService storage;

    @Scheduled(fixedDelay = 2000)
    @Transactional
    public void runOnce() {
        Instant now = Instant.now();
        List<FoodLogTaskEntity> tasks = taskRepo.claimRunnableForUpdate(now, BATCH_SIZE);

        for (FoodLogTaskEntity task : tasks) {
            var logEntity = logRepo.findByIdForUpdate(task.getFoodLogId());

            if (logEntity.getStatus() == FoodLogStatus.DELETED) {
                task.markCancelled(now, "LOG_DELETED", "food_log already deleted");
                taskRepo.save(task);
                continue;
            }

            if (logEntity.getStatus() == FoodLogStatus.DRAFT || logEntity.getStatus() == FoodLogStatus.SAVED) {
                task.markCancelled(now, "ALREADY_DONE", "food_log already processed");
                taskRepo.save(task);
                continue;
            }

            if (logEntity.getImageObjectKey() == null || logEntity.getImageObjectKey().isBlank()) {
                task.markCancelled(now, "IMAGE_OBJECT_KEY_MISSING", "missing imageObjectKey");
                taskRepo.save(task);

                logEntity.setStatus(FoodLogStatus.FAILED);
                logEntity.setLastErrorCode("IMAGE_OBJECT_KEY_MISSING");
                logEntity.setLastErrorMessage("missing imageObjectKey");
                logRepo.save(logEntity);
                continue;
            }

            // ✅ 單一真相：使用 TaskRetryPolicy.MAX_ATTEMPTS
            if (task.getAttempts() >= TaskRetryPolicy.MAX_ATTEMPTS) {
                task.markCancelled(now, "MAX_ATTEMPTS_EXCEEDED", "cancelled after max attempts");
                taskRepo.save(task);

                logEntity.setStatus(FoodLogStatus.FAILED);
                logEntity.setLastErrorCode("MAX_ATTEMPTS_EXCEEDED");
                logEntity.setLastErrorMessage("cancelled after max attempts");
                logRepo.save(logEntity);
                continue;
            }

            try {
                task.markRunning(now); // 你目前的語意：markRunning 會 attempts +1
                taskRepo.save(task);

                var result = providerClient.process(logEntity, storage);
                if (result == null || result.effective() == null) {
                    throw new IllegalStateException("PROVIDER_RETURNED_EMPTY");
                }

                logEntity.setEffective(result.effective());
                logEntity.setProvider(result.provider());
                logEntity.setStatus(FoodLogStatus.DRAFT);
                logEntity.setLastErrorCode(null);
                logEntity.setLastErrorMessage(null);

                task.markSucceeded(now);

                logRepo.save(logEntity);
                taskRepo.save(task);

            } catch (Exception e) {
                log.warn("task failed: {}", task.getId(), e);

                // ✅ 這次失敗後，如果已達最大嘗試次數 → GIVE UP → CANCELLED
                if (task.getAttempts() >= TaskRetryPolicy.MAX_ATTEMPTS) {
                    task.markCancelled(now, "PROVIDER_GIVE_UP", safeMsg(e));
                    taskRepo.save(task);

                    logEntity.setStatus(FoodLogStatus.FAILED);
                    logEntity.setLastErrorCode("PROVIDER_GIVE_UP");   // ✅ 你的測試期待這個
                    logEntity.setLastErrorMessage(safeMsg(e));
                    logRepo.save(logEntity);
                    continue;
                }

                // ✅ 未達上限 → 排程重試
                int delaySec = TaskRetryPolicy.nextDelaySec(task.getAttempts());
                task.markFailed(now, "PROVIDER_FAILED", safeMsg(e), delaySec);
                taskRepo.save(task);

                logEntity.setStatus(FoodLogStatus.FAILED);
                logEntity.setLastErrorCode("PROVIDER_FAILED");
                logEntity.setLastErrorMessage(safeMsg(e));
                logRepo.save(logEntity);
            }
        }
    }

    private static String safeMsg(Throwable t) {
        String m = t.getMessage();
        return (m == null || m.isBlank()) ? t.getClass().getSimpleName() : m;
    }
}
package com.calai.backend.foodlog.task;

import com.calai.backend.foodlog.storage.LocalDiskStorageService;
import com.calai.backend.foodlog.task.config.LocalTempBlobCleanerProperties;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.lang.NonNull;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.time.Duration;
import java.time.Instant;
import java.util.EnumSet;
import java.util.concurrent.atomic.AtomicInteger;

@Slf4j
@Component
@ConditionalOnProperty(
        prefix = "app.storage.local.tmp-cleaner",
        name = "enabled",
        havingValue = "true",
        matchIfMissing = true
)
public class LocalTempBlobCleaner {

    private final LocalDiskStorageService storage;
    private final LocalTempBlobCleanerProperties props;

    public LocalTempBlobCleaner(LocalDiskStorageService storage, LocalTempBlobCleanerProperties props) {
        this.storage = storage;
        this.props = props;
    }

    @Scheduled(
            fixedDelayString = "${app.storage.local.tmp-cleaner.fixed-delay:PT10M}",
            initialDelayString = "${app.storage.local.tmp-cleaner.initial-delay:PT1M}"
    )
    public void clean() {
        if (!props.isEnabled()) return;

        final Path base = storage.getBaseDir().toAbsolutePath().normalize();
        final Path tmpDir = base.resolve(props.getTmpSubdir()).toAbsolutePath().normalize();

        if (!tmpDir.startsWith(base)) {
            log.warn("tmp cleaner skipped: tmpDir not under base. base={}, tmpDir={}", base, tmpDir);
            return;
        }
        if (!Files.exists(tmpDir) || !Files.isDirectory(tmpDir)) return;

        final Instant now = Instant.now();
        final Duration keep = props.getKeep();
        final int maxDepth = Math.max(1, props.getMaxDepth());

        final AtomicInteger deletedFiles = new AtomicInteger(0);
        final AtomicInteger deletedDirs = new AtomicInteger(0);

        try {
            Files.walkFileTree(
                    tmpDir,
                    EnumSet.noneOf(FileVisitOption.class),
                    maxDepth,
                    new SimpleFileVisitor<>() {

                        @Override
                        public @NonNull FileVisitResult visitFile(
                                @NonNull Path file,
                                @NonNull BasicFileAttributes attrs
                        ) {
                            if (!attrs.isRegularFile()) return FileVisitResult.CONTINUE;

                            try {
                                Instant lm = attrs.lastModifiedTime().toInstant();
                                if (Duration.between(lm, now).compareTo(keep) > 0) {
                                    if (Files.deleteIfExists(file)) {
                                        deletedFiles.incrementAndGet();
                                    }
                                }
                            } catch (Exception e) {
                                log.debug("tmp cleaner: delete file failed. file={}", file, e);
                            }
                            return FileVisitResult.CONTINUE;
                        }

                        @Override
                        public @NonNull FileVisitResult postVisitDirectory(@NonNull Path dir, IOException exc) {
                            if (!props.isDeleteEmptyDirs()) return FileVisitResult.CONTINUE;
                            if (dir.equals(tmpDir)) return FileVisitResult.CONTINUE;

                            try (DirectoryStream<Path> ds = Files.newDirectoryStream(dir)) {
                                if (!ds.iterator().hasNext()) {
                                    if (Files.deleteIfExists(dir)) {
                                        deletedDirs.incrementAndGet();
                                    }
                                }
                            } catch (Exception e) {
                                log.debug("tmp cleaner: delete dir failed. dir={}", dir, e);
                            }
                            return FileVisitResult.CONTINUE;
                        }
                    }
            );

            if (deletedFiles.get() > 0 || deletedDirs.get() > 0) {
                log.info("tmp cleaner done. tmpDir={}, deletedFiles={}, deletedDirs={}",
                        tmpDir, deletedFiles.get(), deletedDirs.get());
            }
        } catch (Exception e) {
            log.warn("tmp cleaner failed. tmpDir={}", tmpDir, e);
        }
    }
}
package com.calai.backend.foodlog.task;

import com.calai.backend.foodlog.entity.FoodLogEntity;
import com.calai.backend.foodlog.storage.StorageService;
import com.fasterxml.jackson.databind.JsonNode;

public interface ProviderClient {

    ProviderResult process(FoodLogEntity log, StorageService storage) throws Exception;

    record ProviderResult(JsonNode effective, String provider) {}
}
package com.calai.backend.foodlog.task;

import com.calai.backend.foodlog.entity.FoodLogEntity;
import com.calai.backend.foodlog.storage.StorageService;
import com.fasterxml.jackson.databind.ObjectMapper;

public class StubProviderClient implements ProviderClient {

    private final ObjectMapper om;

    public StubProviderClient(ObjectMapper om) {
        this.om = om;
    }

    @Override
    public ProviderResult process(FoodLogEntity log, StorageService storage) throws Exception {
        var effective = om.readTree("""
          {
            "foodName": "Stub result",
            "quantity": {"value": 1, "unit": "SERVING"},
            "nutrients": {"kcal": 222, "protein": 10, "fat": 8, "carbs": 28},
            "healthScore": 7,
            "confidence": 0.55
          }
        """);
        return new ProviderResult(effective, "STUB");
    }
}
package com.calai.backend.foodlog.task;

/**
 * TaskRetryPolicy 是你 背景任務（FoodLogTaskWorker）重試的「規則表」，集中管理「最多重試幾次、每次隔多久再重試」。
 * MAX_ATTEMPTS=5 代表 最多自動嘗試 5 次，超過就不要再跑（避免無限燒錢/打爆 provider）。
 * nextDelaySec(attempts) 回傳 下一次重試要延後幾秒（2→5→10→20→40→60…）。
 * shouldGiveUp(attempts) 回傳 是否該放棄（達到上限就停止自動重試）。
 * attempts 建議用「markRunning 後的 attempts」：代表 這次是第幾次真正出手呼叫 provider。
 */
public final class TaskRetryPolicy {

    private TaskRetryPolicy() {}

    /** ✅ 超過就停止自動重試（避免燒錢） */
    public static final int MAX_ATTEMPTS = 5;

    /**
     * 退避：2, 5, 10, 20, 40（上限 60）
     * attempts：本次「即將執行」是第幾次（markRunning 後的 attempts）
     */
    public static int nextDelaySec(int attempts) {
        if (attempts <= 1) return 2;
        if (attempts == 2) return 5;
        if (attempts == 3) return 10;
        if (attempts == 4) return 20;
        if (attempts == 5) return 40;
        return 60;
    }

    public static boolean shouldGiveUp(int attempts) {
        return attempts >= MAX_ATTEMPTS;
    }
}
package com.calai.backend.foodlog.time;

import com.calai.backend.foodlog.dto.TimeSource;

import java.time.Duration;
import java.time.Instant;
import java.util.Objects;

/**
 * 決策順序：EXIF > DEVICE_CLOCK > SERVER_RECEIVED
 * 若與 serverReceivedUtc 差距 > 30 天：降級 SERVER_RECEIVED，並 suspect=true
 */
public final class CapturedTimeResolver {

    public record Result(Instant capturedAtUtc, TimeSource source, boolean suspect) {}

    private static final Duration MAX_SKEW = Duration.ofDays(30);

    public Result resolve(Instant exifUtc, Instant deviceUtc, Instant serverReceivedUtc) {
        Objects.requireNonNull(serverReceivedUtc, "serverReceivedUtc");

        Candidate c1 = candidate(exifUtc, TimeSource.EXIF, serverReceivedUtc);
        if (c1 != null) return new Result(c1.instant, c1.source, c1.suspect);

        Candidate c2 = candidate(deviceUtc, TimeSource.DEVICE_CLOCK, serverReceivedUtc);
        if (c2 != null) return new Result(c2.instant, c2.source, c2.suspect);

        return new Result(serverReceivedUtc, TimeSource.SERVER_RECEIVED, false);
    }

    private Candidate candidate(Instant utc, TimeSource src, Instant serverReceivedUtc) {
        if (utc == null) return null;

        Duration skew = Duration.between(serverReceivedUtc, utc).abs();
        if (skew.compareTo(MAX_SKEW) > 0) {
            return new Candidate(serverReceivedUtc, TimeSource.SERVER_RECEIVED, true);
        }
        return new Candidate(utc, src, false);
    }

    private record Candidate(Instant instant, TimeSource source, boolean suspect) {}
}
package com.calai.backend.foodlog.time;

import com.calai.backend.foodlog.storage.StorageService;
import com.drew.imaging.ImageMetadataReader;
import com.drew.metadata.Metadata;
import com.drew.metadata.exif.ExifSubIFDDirectory;

import java.io.InputStream;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.Optional;

/**
 * 讀 EXIF：
 * - DateTimeOriginal: "yyyy:MM:dd HH:mm:ss" (tag 0x9003)
 * - OffsetTimeOriginal: "+08:00" (tag 0x9011, EXIF 2.31)
 *
 * 若 EXIF 沒有 offset：用 clientTz 當本地時區再轉 UTC。
 *
 * ✅ 注意：有些 metadata-extractor 版本沒有 TAG_OFFSET_TIME_ORIGINAL 常數，
 * 所以這裡直接用 tag number 0x9011，避免編譯失敗。
 */
public final class ExifTimeExtractor {

    private ExifTimeExtractor() {}

    private static final DateTimeFormatter EXIF_FMT =
            DateTimeFormatter.ofPattern("yyyy:MM:dd HH:mm:ss");

    // EXIF 2.31 offset tags
    private static final int TAG_OFFSET_TIME_ORIGINAL = 0x9011;

    /**
     * @param storage   你的 StorageService（可開 objectKey）
     * @param objectKey 例如 tempKey
     * @param clientTz  由 App header "X-Client-Timezone" 傳入；若 EXIF 無 offset，用它推回 UTC
     */
    public static Optional<Instant> tryReadCapturedAtUtc(
            StorageService storage,
            String objectKey,
            ZoneId clientTz
    ) {
        if (storage == null || objectKey == null || objectKey.isBlank()) return Optional.empty();
        if (clientTz == null) clientTz = ZoneOffset.UTC;

        try (InputStream in = storage.open(objectKey).inputStream()) {
            Metadata metadata = ImageMetadataReader.readMetadata(in);
            ExifSubIFDDirectory dir = metadata.getFirstDirectoryOfType(ExifSubIFDDirectory.class);
            if (dir == null) return Optional.empty();

            // 1) DateTimeOriginal
            String dt = dir.getString(ExifSubIFDDirectory.TAG_DATETIME_ORIGINAL);
            if (dt == null || dt.isBlank()) return Optional.empty();

            // 2) OffsetTimeOriginal（可能不存在）
            String off = dir.getString(TAG_OFFSET_TIME_ORIGINAL);

            return parseExifDateTimeToInstant(dt, off, clientTz);

        } catch (Exception ignored) {
            return Optional.empty();
        }
    }

    /**
     * ✅ 拆出來方便測試（不用真的 JPEG）。
     */
    static Optional<Instant> parseExifDateTimeToInstant(String exifDateTime, String offset, ZoneId clientTz) {
        if (exifDateTime == null || exifDateTime.isBlank()) return Optional.empty();
        if (clientTz == null) clientTz = ZoneOffset.UTC;

        final LocalDateTime ldt;
        try {
            ldt = LocalDateTime.parse(exifDateTime.trim(), EXIF_FMT);
        } catch (DateTimeParseException e) {
            return Optional.empty();
        }

        // 有 offset：用 offset 直接轉 UTC
        if (offset != null && !offset.isBlank()) {
            try {
                ZoneOffset zo = ZoneOffset.of(offset.trim());
                return Optional.of(OffsetDateTime.of(ldt, zo).toInstant());
            } catch (Exception ignored) {
                // offset 格式怪：降級成 clientTz
            }
        }

        // 無 offset 或 offset 不合法：用 clientTz 當地時間轉 UTC
        try {
            return Optional.of(ZonedDateTime.of(ldt, clientTz).toInstant());
        } catch (Exception ignored) {
            return Optional.empty();
        }
    }
}
package com.calai.backend.foodlog.web;

import com.calai.backend.common.web.RequestIdFilter;
import com.calai.backend.foodlog.controller.FoodLogController;
import com.calai.backend.foodlog.controller.FoodLogImageController;
import com.calai.backend.foodlog.dto.FoodLogErrorResponse;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.io.FileNotFoundException;

@RestControllerAdvice(assignableTypes = {
        FoodLogController.class,
        FoodLogImageController.class
})
@Order(Ordered.HIGHEST_PRECEDENCE)
public class FoodLogExceptionAdvice {

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<FoodLogErrorResponse> handleIllegalArg(IllegalArgumentException e, HttpServletRequest req) {
        String code = norm(e.getMessage(), "BAD_REQUEST");
        HttpStatus status = switch (code) {
            case "FOOD_LOG_NOT_FOUND" -> HttpStatus.NOT_FOUND;
            case "FOOD_LOG_DELETED" -> HttpStatus.GONE;

            case "FOOD_LOG_NOT_READY",
                 "FOOD_LOG_FAILED",
                 "FOOD_LOG_NOT_SAVABLE",
                 "DATE_RANGE_REQUIRED",
                 "DATE_RANGE_INVALID",
                 "FOOD_LOG_NOT_EDITABLE",
                 "FIELD_KEY_INVALID",
                 "OVERRIDE_VALUE_INVALID",
                 "PAGE_SIZE_TOO_LARGE" -> HttpStatus.CONFLICT;

            case "FILE_REQUIRED",
                 "FILE_TOO_LARGE",
                 "UNSUPPORTED_IMAGE_FORMAT",
                 "UNSUPPORTED_CONTENT_TYPE" -> HttpStatus.BAD_REQUEST;

            default -> HttpStatus.BAD_REQUEST;
        };

        return ResponseEntity.status(status)
                .body(err(code, e, req)); // ✅ 補齊 5 欄位
    }

    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<FoodLogErrorResponse> handleIllegalState(IllegalStateException e, HttpServletRequest req) {
        String code = norm(e.getMessage(), "ILLEGAL_STATE");
        HttpStatus status = switch (code) {
            case "IMAGE_OBJECT_KEY_MISSING" -> HttpStatus.CONFLICT;
            case "EMPTY_IMAGE" -> HttpStatus.BAD_REQUEST;
            default -> HttpStatus.INTERNAL_SERVER_ERROR;
        };

        return ResponseEntity.status(status)
                .body(err(code, e, req)); // ✅ 補齊 5 欄位
    }

    @ExceptionHandler(RequestInProgressException.class)
    public ResponseEntity<FoodLogErrorResponse> handleReqInProgress(RequestInProgressException e, HttpServletRequest req) {
        return ResponseEntity.status(HttpStatus.CONFLICT)
                .header(HttpHeaders.RETRY_AFTER, String.valueOf(e.retryAfterSec()))
                .body(new FoodLogErrorResponse(
                        "REQUEST_IN_PROGRESS",
                        safeMsg(e),
                        rid(req),
                        "RETRY_LATER",
                        e.retryAfterSec()
                ));
    }

    @ExceptionHandler(SubscriptionRequiredException.class)
    public ResponseEntity<FoodLogErrorResponse> handleSubRequired(SubscriptionRequiredException e, HttpServletRequest req) {
        return ResponseEntity.status(402)
                .body(new FoodLogErrorResponse(
                        "SUBSCRIPTION_REQUIRED",
                        safeMsg(e),
                        rid(req),
                        e.clientAction(),
                        null
                ));
    }

    @ExceptionHandler(QuotaExceededException.class)
    public ResponseEntity<FoodLogErrorResponse> handleQuota(QuotaExceededException e, HttpServletRequest req) {
        return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS)
                .header(HttpHeaders.RETRY_AFTER, String.valueOf(e.retryAfterSec()))
                .body(new FoodLogErrorResponse(
                        "QUOTA_EXCEEDED",
                        safeMsg(e),
                        rid(req),
                        e.clientAction(),
                        e.retryAfterSec()
                ));
    }

    @ExceptionHandler(FileNotFoundException.class)
    public ResponseEntity<FoodLogErrorResponse> handleNotFound(FileNotFoundException e, HttpServletRequest req) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(err("OBJECT_NOT_FOUND", e, req)); // ✅ 補齊 5 欄位
    }

    @ExceptionHandler(SecurityException.class)
    public ResponseEntity<FoodLogErrorResponse> handleSecurity(SecurityException e, HttpServletRequest req) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(err("INVALID_OBJECT_KEY", e, req)); // ✅ 補齊 5 欄位
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<FoodLogErrorResponse> handleUnknown(Exception e, HttpServletRequest req) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(err("INTERNAL_ERROR", e, req)); // ✅ 補齊 5 欄位
    }

    @ExceptionHandler(TooManyInFlightException.class)
    public ResponseEntity<FoodLogErrorResponse> handleInFlight(TooManyInFlightException e, HttpServletRequest req) {
        return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS)
                .header(HttpHeaders.RETRY_AFTER, String.valueOf(e.retryAfterSec()))
                .body(new FoodLogErrorResponse(
                        "TOO_MANY_IN_FLIGHT",
                        safeMsg(e),
                        rid(req),
                        e.clientAction(),
                        e.retryAfterSec()
                ));
    }

    @ExceptionHandler(RateLimitedException.class)
    public ResponseEntity<FoodLogErrorResponse> handleRateLimited(RateLimitedException e, HttpServletRequest req) {
        return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS)
                .header(HttpHeaders.RETRY_AFTER, String.valueOf(e.retryAfterSec()))
                .body(new FoodLogErrorResponse(
                        "RATE_LIMITED",
                        safeMsg(e),
                        rid(req),
                        e.clientAction(),
                        e.retryAfterSec()
                ));
    }

    // ===== helpers =====

    private static FoodLogErrorResponse err(String code, Throwable e, HttpServletRequest req) {
        return new FoodLogErrorResponse(
                code,
                safeMsg(e),
                rid(req),
                null,  // clientAction
                null   // retryAfterSec
        );
    }

    private static String rid(HttpServletRequest req) {
        return RequestIdFilter.getOrCreate(req);
    }

    private static String norm(String msg, String fallback) {
        if (msg == null) return fallback;
        String c = msg.trim();
        return c.isEmpty() ? fallback : c;
    }

    private static String safeMsg(Throwable t) {
        String m = t.getMessage();
        return (m == null || m.isBlank()) ? null : m;
    }
}
package com.calai.backend.foodlog.web;

public class QuotaExceededException extends RuntimeException {
    private final int retryAfterSec;
    private final String clientAction;

    public QuotaExceededException(String message, int retryAfterSec, String clientAction) {
        super(message);
        this.retryAfterSec = retryAfterSec;
        this.clientAction = clientAction;
    }

    public int retryAfterSec() { return retryAfterSec; }
    public String clientAction() { return clientAction; }
}
package com.calai.backend.foodlog.web;

public class RateLimitedException extends RuntimeException {

    private final int retryAfterSec;
    private final String clientAction;

    public RateLimitedException(String message, int retryAfterSec, String clientAction) {
        super(message);
        this.retryAfterSec = retryAfterSec;
        this.clientAction = clientAction;
    }

    public int retryAfterSec() { return retryAfterSec; }
    public String clientAction() { return clientAction; }
}
package com.calai.backend.foodlog.web;

public class RequestInProgressException extends RuntimeException {
    private final int retryAfterSec;

    public RequestInProgressException(String message, int retryAfterSec) {
        super(message);
        this.retryAfterSec = retryAfterSec;
    }

    public int retryAfterSec() { return retryAfterSec; }
}
package com.calai.backend.foodlog.web;

public class SubscriptionRequiredException extends RuntimeException {
    private final String clientAction;

    public SubscriptionRequiredException(String message, String clientAction) {
        super(message);
        this.clientAction = clientAction;
    }

    public String clientAction() { return clientAction; }
}
package com.calai.backend.foodlog.web;

public class TooManyInFlightException extends RuntimeException {

    private final int retryAfterSec;
    private final String clientAction;

    public TooManyInFlightException(String message, int retryAfterSec, String clientAction) {
        super(message);
        this.retryAfterSec = retryAfterSec;
        this.clientAction = clientAction;
    }

    public int retryAfterSec() { return retryAfterSec; }
    public String clientAction() { return clientAction; }
}


server:
  port: 8080
  address: 0.0.0.0

spring:
  task:
    scheduling:
      pool:
        size: 6                 # 由 2 提升到 6：promotion/purge/retention 等可並行
      thread-name-prefix: "sched-"
      shutdown:
        await-termination: true
        await-termination-period: 30s
    # 若你偏好全局設定時區（依 Boot 版本），也可加上（仍建議註解端顯式 zone 保險）
    # time-zone: Asia/Taipei
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3307/calai?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC&characterEncoding=utf8&createDatabaseIfNotExist=true
    username: root
    password: root

  jpa:
    hibernate:
      ddl-auto: none             # 無自動建表；請用 Flyway/Liquibase
    open-in-view: false
    show-sql: false
    properties:
      hibernate:
        format_sql: false
        jdbc:
          time_zone: UTC         # 與 DB 溝通用 UTC

  data:
    redis:
      host: localhost
      port: 6379

  mail:
    host: smtp.gmail.com
    port: 587
    test-connection: true
    username: "${SMTP_USERNAME}"
    password: "${SMTP_PASSWORD}"
    properties:
      mail.transport.protocol: smtp
      mail.smtp.auth: true
      mail.smtp.starttls.enable: true
      mail.smtp.starttls.required: true   # 建議加上
      mail.smtp.connectiontimeout: 5000   # (ms) 避免連線卡死
      mail.smtp.timeout: 5000
      mail.smtp.writetimeout: 5000
    default-encoding: UTF-8

management:
  endpoints:
    web:
      exposure:
        include: health,info,scheduledtasks

app:
  crypto:
    aesgcm:
      key-b64: "${APP_CRYPTO_AESGCM_KEY_B64}"
  foodlog:
    provider: "STUB"  # STUB / TODO 正式環境改 : LOGMEAL
  provider:
    logmeal:
      base-url: "https://api.logmeal.com"
      api-user-token: "${LOGMEAL_APIUSER_TOKEN}"
      connect-timeout: 5s
      read-timeout: 25s
  google:
    web-client-id: "${GOOGLE_WEB_CLIENT_ID_DEV:575775859979-nuhb6lmchca4sn5719193uke61eda7pq.apps.googleusercontent.com}"
  auth:
    access-ttl-sec: 900
    refresh-ttl-sec: 2592000
  security:
    allow-origins: "*"
  email:
    enabled: true
    otp-length: 4
    ttl-minutes: 10
    # 若使用 Gmail SMTP，from 最好等於 username；否則容易被覆寫或遭拒收
    sender: "st9360606@gmail.com"
    # 若要用自家網域 no-reply@bitecal.app，建議改用 SendGrid/SES 並設定 SPF/DKIM/DMARC
  storage:
    weight-photos-dir: uploads/weight-photos
    local:
      base-dir: ./data
      tmp-cleaner:
        enabled: true
        tmp-subdir: "blobs/tmp"     # 相對於 base-dir  cleaner 只會掃描 base-dir/tmp-subdir 子樹，並做 tmpDir.startsWith(baseDir) 防呆，避免配置錯誤誤刪其他路徑。建議 production 若改用雲端 object storage，可直接 enabled=false 關閉。
        keep: "PT6H"                # 超過 6 小時的 tmp 檔會刪
        fixed-delay: "PT10M"        # 每 10 分鐘跑一次
        initial-delay: "PT1M"       # 啟動後 1 分鐘第一次執行
        max-depth: 8                # 避免深層走訪拖慢
        delete-empty-dirs: true
  features:
    dev-image-endpoint: true   # TODO 上線要改成 false
alias:
  promotion:
    # 不再用 cron（避免 */3 的曆法語意），改 72h 固定延遲
    fixedDelay: "PT72H"
    initialDelay: "PT5M"
    windowDays: 30
    minUsers: 3
    minCount: 7
    minMedian: 0.88

  events:
    purge:
      enabled: true
      cron: "0 10 4 * * *"      # 每天 04:10 清一次（可調）
      retentionDays: 45         # 留存 45 天（promotion 只看 45 天）
      batchSize: 50000          # 依你資料量調整（1~10萬都可）
      maxTotalPerRun: 1000000   # 新增：單次 run 總上限
      pauseMsBetweenBatches: 50 # 新增：批次間暫停，降低鎖壓力

logging:
  level:
    org.springframework.scheduling: INFO
    com.calai.backend.workout.job: INFO

workout:
  estimate:
    blacklistPolicy: block   # 可選：generic（現狀）、block（阻擋）、audit（只記錄與回傳 not_found）

-- MySQL 8.x
DROP TABLE IF EXISTS food_logs;

CREATE TABLE food_logs
(
    id                     CHAR(36)                                            NOT NULL,
    user_id                BIGINT                                              NOT NULL,

    status                 ENUM ('PENDING','DRAFT','SAVED','FAILED','DELETED') NOT NULL,
    method                 VARCHAR(16)                                         NOT NULL, -- PHOTO/ALBUM/BARCODE/LABEL
    provider               VARCHAR(32)                                         NOT NULL, -- STUB/LOGMEAL/...
    degrade_level          VARCHAR(8)                                          NULL,     -- DG-0..DG-4

    -- time (一律以 UTC 寫入到 DATETIME)
    captured_at_utc        DATETIME(6)                                         NOT NULL,
    captured_tz            VARCHAR(64)                                         NOT NULL, -- IANA
    captured_local_date    DATE                                                NOT NULL, -- for summary
    server_received_at_utc DATETIME(6)                                         NOT NULL,

    time_source            ENUM ('EXIF','DEVICE_CLOCK','SERVER_RECEIVED')      NOT NULL,
    time_suspect           BOOLEAN                                             NOT NULL DEFAULT FALSE,

    -- input refs
    image_object_key       TEXT                                                NULL,
    image_sha256           CHAR(64)                                            NULL,
    image_content_type     VARCHAR(64)                                         NULL,     -- ✅ 原本 ALTER 的欄位：合併進來
    image_size_bytes       BIGINT                                              NULL,     -- ✅ 原本 ALTER 的欄位：合併進來
    barcode                VARCHAR(64)                                         NULL,

    -- effective values（列表/彙總以此為準）
    effective              JSON                                                NULL,

    -- original snapshot（Step2 再做表/ref）
    original_snapshot_ref  CHAR(36)                                            NULL,

    -- error / deleted
    last_error_code        VARCHAR(64)                                         NULL,
    last_error_message     TEXT                                                NULL,
    deleted_at_utc         DATETIME(6)                                         NULL,
    deleted_by             VARCHAR(16)                                         NULL,     -- USER/SYSTEM/ADMIN

    created_at_utc         DATETIME(6)                                         NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
    updated_at_utc         DATETIME(6)                                         NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6),

    PRIMARY KEY (id),

    -- ✅ 1) 歷史列表：user + status + local_date 範圍（核心）
    -- 若你未來把排序改成 ORDER BY captured_local_date DESC, captured_at_utc DESC，這個索引會更吃香
    INDEX idx_food_logs_user_status_date (user_id, status, captured_local_date, captured_at_utc),

    -- ✅ 2) 去重命中：user + sha + status + created_at_utc（limit 1）
    INDEX idx_food_logs_user_sha_status_created (user_id, image_sha256, status, created_at_utc)

    -- ✅ 可選：如果你確定 users(id) 存在且想強約束
    -- ,CONSTRAINT fk_food_logs_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_0900_ai_ci;


-- === food_log_tasks（承接 PENDING）===
DROP TABLE IF EXISTS food_log_tasks;

CREATE TABLE food_log_tasks
(
    id                 CHAR(36)                                                   NOT NULL,
    food_log_id        CHAR(36)                                                   NOT NULL,

    task_status        ENUM ('QUEUED','RUNNING','SUCCEEDED','FAILED','CANCELLED') NOT NULL,
    attempts           INT                                                        NOT NULL DEFAULT 0,
    next_retry_at_utc  DATETIME(6)                                                NULL,

    poll_after_sec     INT                                                        NOT NULL DEFAULT 2,

    last_error_code    VARCHAR(64)                                                NULL,
    last_error_message TEXT                                                       NULL,

    created_at_utc     DATETIME(6)                                                NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
    updated_at_utc     DATETIME(6)                                                NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6),

    PRIMARY KEY (id),

    -- ✅ 一個 food_log 對應一個 task（Step2 MVP 先這樣）
    UNIQUE KEY ux_food_log_tasks_food_log_id (food_log_id),

    INDEX idx_food_log_tasks_status (task_status, next_retry_at_utc),

    CONSTRAINT fk_food_log_tasks_food_log
        FOREIGN KEY (food_log_id) REFERENCES food_logs (id)
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_0900_ai_ci;


-- === food_log_overrides（回溯覆寫）===
CREATE TABLE IF NOT EXISTS food_log_overrides
(
    id             CHAR(36)    NOT NULL,
    food_log_id    CHAR(36)    NOT NULL,

    field_key      VARCHAR(32) NOT NULL, -- FOOD_NAME/QUANTITY/NUTRIENTS/HEALTH_SCORE...
    old_value_json JSON        NULL,
    new_value_json JSON        NOT NULL,

    editor_type    VARCHAR(16) NOT NULL, -- USER/ADMIN/SYSTEM
    reason         TEXT        NULL,
    edited_at_utc  DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),

    PRIMARY KEY (id),

    INDEX idx_food_log_overrides_log (food_log_id, edited_at_utc),

    CONSTRAINT fk_food_log_overrides_food_log
        FOREIGN KEY (food_log_id) REFERENCES food_logs (id)
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_0900_ai_ci;


-- === usage_counters（配額：server_now + user_tz 的 local_date）===
CREATE TABLE IF NOT EXISTS usage_counters
(
    id             BIGINT      NOT NULL AUTO_INCREMENT,
    user_id        BIGINT      NOT NULL,
    local_date     DATE        NOT NULL,
    used_count     INT         NOT NULL DEFAULT 0,
    updated_at_utc DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6),

    PRIMARY KEY (id),
    UNIQUE KEY uk_usage_counters_user_date (user_id, local_date),
    INDEX idx_usage_counters_user_date (user_id, local_date)
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_0900_ai_ci;


-- === user_entitlements（訂閱/試用）===
CREATE TABLE IF NOT EXISTS user_entitlements
(
    id                   CHAR(36)    NOT NULL,
    user_id              BIGINT      NOT NULL,
    entitlement_type     VARCHAR(16) NOT NULL, -- TRIAL/MONTHLY/YEARLY
    status               VARCHAR(16) NOT NULL, -- ACTIVE/EXPIRED/CANCELLED
    valid_from_utc       DATETIME(6) NOT NULL,
    valid_to_utc         DATETIME(6) NOT NULL,

    purchase_token_hash  CHAR(64)    NULL,
    last_verified_at_utc DATETIME(6) NULL,

    created_at_utc       DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
    updated_at_utc       DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6),

    PRIMARY KEY (id),

    INDEX idx_entitlements_user (user_id, status, valid_to_utc)
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_0900_ai_ci;


-- === deletion_jobs（刪圖/刪 payload 任務）===
DROP TABLE IF EXISTS deletion_jobs;

CREATE TABLE IF NOT EXISTS deletion_jobs
(
    id                CHAR(36)    NOT NULL,
    food_log_id       CHAR(36)    NOT NULL,

    -- ✅ 不要靠 parse objectKey 推導：直接把必要欄位放進來
    user_id           BIGINT      NOT NULL,
    sha256            CHAR(64)    NULL,
    ext               VARCHAR(8)  NULL,

    job_status        VARCHAR(16) NOT NULL, -- QUEUED/RUNNING/SUCCEEDED/FAILED/CANCELLED
    attempts          INT         NOT NULL DEFAULT 0,
    next_retry_at_utc DATETIME(6) NULL,

    image_object_key  TEXT        NULL,
    last_error        TEXT        NULL,

    created_at_utc    DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
    updated_at_utc    DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6),

    PRIMARY KEY (id),

    INDEX idx_deletion_jobs_food_log_id (food_log_id),
    INDEX idx_deletion_jobs_status (job_status, next_retry_at_utc),
    INDEX idx_deletion_jobs_user_sha (user_id, sha256),

    CONSTRAINT fk_deletion_jobs_food_log
        FOREIGN KEY (food_log_id) REFERENCES food_logs (id)
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_0900_ai_ci;



CREATE TABLE IF NOT EXISTS food_log_requests
(
    id              BIGINT       NOT NULL AUTO_INCREMENT,
    user_id         BIGINT       NOT NULL,
    request_id      VARCHAR(64)  NOT NULL,  -- 你 RequestIdFilter 產生的 UUID 字串
    food_log_id     CHAR(36)     NULL,      -- attach 後才有
    status          VARCHAR(16)  NOT NULL,  -- RESERVED/ATTACHED/FAILED
    error_code      VARCHAR(64)  NULL,
    error_message   TEXT         NULL,

    created_at_utc  DATETIME(6)  NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
    updated_at_utc  DATETIME(6)  NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6),

    PRIMARY KEY (id),
    UNIQUE KEY uk_food_log_requests_user_req (user_id, request_id),
    INDEX idx_food_log_requests_log (food_log_id)
) ENGINE=InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_0900_ai_ci;


CREATE TABLE IF NOT EXISTS image_blobs
(
    id              BIGINT      NOT NULL AUTO_INCREMENT,
    user_id         BIGINT      NOT NULL,
    sha256          CHAR(64)    NOT NULL,

    object_key      TEXT        NOT NULL,    -- user-<uid>/blobs/sha256/<sha>.jpg
    content_type    VARCHAR(64) NOT NULL,
    size_bytes      BIGINT      NOT NULL,
    ext             VARCHAR(8)  NOT NULL,    -- .jpg/.png

    ref_count       INT         NOT NULL DEFAULT 1,

    created_at_utc  DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
    updated_at_utc  DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6),

    PRIMARY KEY (id),
    UNIQUE KEY uk_image_blobs_user_sha (user_id, sha256),
    INDEX idx_image_blobs_user (user_id)
) ENGINE=InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_0900_ai_ci;



CREATE TABLE IF NOT EXISTS logmeal_accounts
(
    id                 BIGINT      NOT NULL AUTO_INCREMENT,
    user_id            BIGINT      NOT NULL,
    -- 你從 LogMeal 拿到的 APIUser token（務必加密後存）
    api_user_token_enc TEXT        NOT NULL,
    status             VARCHAR(16) NOT NULL DEFAULT 'ACTIVE', -- ACTIVE/DISABLED
    created_at_utc     DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
    updated_at_utc     DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6),

    PRIMARY KEY (id),
    UNIQUE KEY uk_logmeal_accounts_user (user_id),
    INDEX idx_logmeal_accounts_status (status)
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_0900_ai_ci;




## TL;DR（到目前為止我們「定案」了什麼）

1. **四入口其實是三條管線**：PHOTO/ALBUM（影像辨識）、LABEL（OCR+解析）、BARCODE（產品資料庫查詢）→ 最後都輸出同一份 **NutritionResult**。
2. **後端必須做 Proxy + 成本守門**：金鑰/配額/降級/去重/續驗 entitlement 都在後端做，App 只打你的 API。
3. **FoodLog 狀態機補齊並能閉環**：`PENDING / DRAFT / SAVED / FAILED / DELETED`，承接 DG-3（排隊非同步）+ 可查進度 + 可重試 + 可刪除。
4. **時間與配額以 server 為唯一基準**：落庫有 EXIF/DEVICE/SERVER 優先序與合理性校驗；配額結算日用 `server_now_utc + user_tz`，避免改手機時間刷額度。
5. **可編輯一定要可回溯**：用 `food_log_overrides` 記錄欄位覆寫軌跡（old/new + 時間 + 來源），主表保留「目前生效值」。
6. **MVP 的安全策略偏保守**：近似去重（pHash）只當候選；快取必帶 `ttl + version` 防快取污染；訂閱做「初驗 + 排程續驗」先閉環，RTDN 之後再上。

---

# 你可以直接複製到下一個對話的「交接摘要」

## 1) 專案背景與目標（你要做的產品）

* Android（Kotlin/Compose）卡路里追蹤 App，核心是「卡路里相機」：

  * 四入口：食物拍照、相簿上傳、條碼掃描、標籤拍照（OCR）
  * 輸出：calories / protein / fat / carbs / fiber / sugar / sodium + 健康分數 1–10
* 商業模式：**3 天試用 + 月/年訂閱**（沒有免費方案）
* 原則：對標體驗但不抄 UI/素材/文案；先 MVP 可跑可上線，再逐步提升準確度與 UX。

---

## 2) 我們目前的總體設計（已定案的關鍵決策）

### 2.1 四入口 → 統一輸出（NutritionResult）

* 不管入口是 PHOTO / ALBUM / LABEL / BARCODE，最後都回同一個「結果結構」，App 才能共用 UI/流程。

### 2.2 後端 Proxy（安全與成本）

* 任何第三方辨識/OCR/營養資料查詢都透過後端，避免：

  * API key 外洩
  * 用戶繞過你的配額
  * 你無法做降級/風控/快取/追蹤

### 2.3 FoodLog 狀態機（承接 DG-3 非同步）

* 狀態：`PENDING / DRAFT / SAVED / FAILED / DELETED`
* 顯示策略（最小可行）：

  * 歷史列表：只顯示 `SAVED`
  * 單筆詳情：所有狀態都能查（DELETED 視策略）
* 轉移摘要：

  * 同步成功：建立後直接 `DRAFT`
  * DG-3 排隊：建立後 `PENDING`，完成後 `PENDING → DRAFT`
  * 失敗：`PENDING → FAILED`，可重試
  * 存入歷史：`DRAFT → SAVED`
  * 刪除：任何狀態 `→ DELETED`（並觸發刪圖/刪資料 job）

### 2.4 可編輯一定要可回溯（Overrides）

* 主表保留「目前生效值」便於查詢/彙總
* `food_log_overrides` 紀錄每次修改：`field_key + old_value_json + new_value_json + edited_at + editor_type + reason`

### 2.5 時間/時區落庫規則 + 反作弊

* DB 必存：`captured_at_utc`（唯一真相）、`captured_tz`（IANA）、`captured_local_date`（彙總 key）、`server_received_at_utc`、`time_source`、`time_suspect`
* 落庫優先序：EXIF（合理）> DEVICE_CLOCK（合理）> SERVER_RECEIVED
* 合理性校驗：`abs(candidate - server_received) > X days` → 降級採 server_received，並標記 suspect
* **配額結算日**：一律用 `server_now_utc + user_tz → today_local_date`，不可用 client 傳值（防改手機時間刷額度）

### 2.6 去重快取（MVP 安全版）

* 強 hash（SHA-256）做「同圖必命中」
* pHash 只做候選（MVP 不做「近似直接回」或必須二次確認）
* 快取條目必帶：`ttl + provider/model/parser/score version`，避免快取污染/版本升級套錯

### 2.7 訂閱 Entitlement（初驗 + 排程續驗閉環）

* 購買 token 只代表「當下」
* MVP：後端驗證入庫 + 排程 re-verify 活躍用戶（例如每 6 小時/每日）
* 進階：RTDN/webhook 放 v1.1

### 2.8 API 契約（同一種 Envelope）

* 四入口與查詢/重試/存檔/刪除，都回「同一種回應外型」
* 降級/超限即使走 429，body 也同型，App 不需要為每個 endpoint 寫特判。

### 2.9 隱私/合規（MVP 必可驗收）

* 單筆刪除：DB + 圖片（立即刪或排程刪，但要可追蹤）
* 全帳號刪除：App 內必有入口（刪除請求/流程可追蹤）
* 清楚告知：照片可能送第三方辨識
* 健康分數免責：避免醫療暗示/治療宣稱

---

## 3) 我們「做到哪裡」了（以你剛剛說的 S4-17~S4-19 為準）

> 我沒有直接看到你的 repo 實作，但依你回報「已完成 S4-17~S4-19」，我在交接筆記中把它視為已完成（下一步會把它接起來往下推）。

你目前等同已完成/定案：

* 食物相機 MVP 的 **PRD/SRS v1.0 修正版**（含狀態機、DG-0~DG-4、時間規則、配額基準、覆寫回溯、去重快取原則、entitlement 閉環、刪除合規）。
* DB/服務端設計方向：

  * `food_logs` 主表（含狀態、時間欄位、method/provider、結果有效值、trace/ref）
  * `food_log_tasks`（承接 PENDING、重試/進度/錯誤）
  * `food_log_overrides`（使用者覆寫軌跡）
  * counters / entitlements / deletion_jobs 的存在與責任邊界

---

# 4) 接下來還有多少要做（我建議的「往下推」順序）

下面是從「規格定案」走到「可上線 MVP」的路徑，你可以照順序一段一段做，每段都能 Demo。

## Phase 1：後端 MVP 閉環（先把資料流跑通）

1. **DB migration 完整化**：把上述表與索引/enum/約束、欄位命名定下來（尤其 captured_*、status、task）。
2. **統一 API 契約落地**：四入口 + 查單筆 + retry + save + delete（即使先用假 provider/mock，也要回同型 Envelope）。
3. **DG Guard（成本守門）先做「最小版」**：先做 daily cap / concurrency limit / retry-after。
4. **DG-3 非同步最小 worker**：MVP 可先用 DB 輪詢/排程當 worker（不一定要上 queue），但要有 task 狀態、attempt、next_retry。
5. **Object Storage 串接最小版**：原圖/縮圖 key + metadata，能刪。
6. **Deletion job 真的能跑完**：單筆刪除與全帳號刪除請求至少能落庫、可查狀態。

## Phase 2：Android MVP（讓用戶端完整走一遍）

7. 四入口 UI flow 串起來：拍照/相簿/條碼/標籤 → 呼叫你的 API → 顯示結果頁。
8. PENDING UX：輪詢查狀態 + 超時/失敗引導（重試、改用 LABEL/BARCODE）。
9. DRAFT 可編輯：修改食物名稱/份量/營養素 → 送回後端 → 產生 override。
10. SAVED 歷史：日彙總/列表只抓 SAVED；DRAFT 不進歷史。

## Phase 3：訂閱與配額（開始能控成本、能收費）

11. Google Play Billing：購買成功上送 token → 後端 verify → entitlements 生效。
12. 後端排程 re-verify：取消/到期/退款會在 N 小時內反映；配額計算跟著變動。

## Phase 4：上架合規與風險收斂（避免被打槍）

13. 隱私權政策、資料刪除流程頁（App 內入口）、健康免責聲明、第三方處理揭露。
14. 監控與稽核：request_id / provider_ref / 任務錯誤碼 / 用量統計，方便客服與除錯。

---

## Backlog / 待辦清單（下一階段：從「規格定案」走到「可 Demo 的後端閉環」）

| ID   | User Story                                                                 | 驗收準則                                                 | 估點 | 依賴             | 風險                   |
| ---- | -------------------------------------------------------------------------- | ---------------------------------------------------- | -: | -------------- | -------------------- |
| B-01 | DB Migration 完整化（logs/tasks/overrides/counters/entitlements/deletion_jobs） | 本機可一鍵 migrate；必要索引/約束齊全；能建立/查詢/刪除一筆 FoodLog          |  8 | Flyway/DB      | 欄位變動牽連 API/組裝成本      |
| B-02 | 統一 API Envelope 契約落地                                                       | 四入口 + GET 單筆 + save/delete/retry 皆回同型；錯誤/降級同型        |  5 | Controller 規範  | App 端若先做特判會返工        |
| B-03 | DG Guard 最小版（daily cap + retry-after + concurrency）                        | 超限會被擋且回同型 body；server 基準日不受 client 影響                |  8 | counters       | 風控太嚴/太鬆都會出事          |
| B-04 | DG-3 非同步任務最小閉環（先用排程當 worker）                                               | 觸發 DG-3 回 PENDING；輪詢可轉 DRAFT 或 FAILED；FAILED 可 retry | 13 | tasks 表/排程     | 沒有真正 queue 會有堆積風險    |
| B-05 | Object Storage 最小串接 + 影像 metadata                                          | 上傳後可拿到 object_key；刪除會清掉對應物件（或進 deletion job）         |  8 | Storage        | 刪圖漏掉=合規風險            |
| B-06 | Deletion Job 可稽核（單筆/全帳號）                                                   | 刪除有狀態；完成後查不到 DB 且 storage key 不存在（或可證明已排程）           |  8 | Storage/排程     | 漏刪/殘留資料              |
| B-07 | Entitlement 初驗資料模型（先不接 Play 真驗）                                            | entitlement 可入庫、可過期、可被排程刷新（mock 亦可）                  |  5 | entitlements 表 | 後續接 Play verify 需改欄位 |

---

## 風險提示與替代方案（你下一階段最常踩的雷）

* **狀態機漏轉**：一旦出現「卡在 PENDING」一定會爆客服；務必做超時策略 + FAILED + retry。
* **配額日邊界**：DST/換時區很容易算錯；先把「server_now_utc + user_tz → local_date」寫成唯一函式，所有地方共用。
* **近似去重誤判**：MVP 寧可少命中也不要套錯；先只做同圖 hash 命中。
* **健康分數宣稱**：避免「治療/診斷」語氣；用「參考/建議/非醫療」措辭，並允許使用者修改。
* **刪除合規**：照片上傳第三方時，政策與刪除流程要可說清楚；刪除 job 必須可追蹤。

---


以上是我目前相關所有的程式碼和規格書，請你先不用寫程式碼給我，請你先重新整理一下，目前我們做到哪一個階段，還剩下哪些步驟要做?
